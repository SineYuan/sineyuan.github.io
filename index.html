<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>STep by STep</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="STep by STep">
<meta property="og:url" content="http://sineyuan.github.io/index.html">
<meta property="og:site_name" content="STep by STep">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STep by STep">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">STep by STep</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/SineYuan" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/19/tornado-source-code-2/">tornado源码分析笔记(2)</a>
          </li>
        
          <li>
            <a href="/2016/01/19/tornado-source-code-1/">tornado源码分析笔记(1)</a>
          </li>
        
          <li>
            <a href="/2016/01/06/python-captcha/">使用Python做验证码识别</a>
          </li>
        
          <li>
            <a href="/2016/01/02/android-studio-tess-two/">在Android Studio中使用tess-Two</a>
          </li>
        
          <li>
            <a href="/2015/09/22/migrate-to-hexo/">博客迁移到Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-tornado-source-code-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/19/tornado-source-code-2/" class="article-date">
  <time datetime="2016-01-19T13:01:28.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/tornado-source-code-2/">tornado源码分析笔记(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>IOLoop</code>就是 tornado 的事件循环，是一个全局的单例，通过<code>IOLoop.current()</code>或<code>IOLoop.instance()</code>访问。<code>IOLoop.current()</code>内部调用的也是<code>instance()</code>方法。所以我们来看<code>instance()</code>:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">IOLoop</span><span class="params">(Configurable)</span>:</span>

    ...

    <span class="comment"># Global lock for creating global IOLoop instance</span>
        _instance_lock = threading.Lock()

        _current = threading.local()

<span class="decorator">        @staticmethod</span>
        <span class="function"><span class="keyword">def</span> <span class="title">instance</span><span class="params">()</span>:</span>
            <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):
                <span class="keyword">with</span> IOLoop._instance_lock:
                    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(IOLoop, <span class="string">"_instance"</span>):
                        <span class="comment"># New instance after double check</span>
                        IOLoop._instance = IOLoop()
            <span class="keyword">return</span> IOLoop._instance
</code></pre><p><code>IOLoop</code>没有<code>__init__()</code>函数，所以我们要去看它的父类<code>Configurable</code>:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Configurable</span><span class="params">(object)</span>:</span>

    __impl_class = <span class="keyword">None</span>
    __impl_kwargs = <span class="keyword">None</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span>
        base = cls.configurable_base()
        init_kwargs = {}
        <span class="keyword">if</span> cls <span class="keyword">is</span> base:
            impl = cls.configured_class()
            <span class="keyword">if</span> base.__impl_kwargs:
                init_kwargs.update(base.__impl_kwargs)
        <span class="keyword">else</span>:
            impl = cls
        init_kwargs.update(kwargs)
        instance = super(Configurable, cls).__new__(impl)

        instance.initialize(*args, **init_kwargs)
        <span class="keyword">return</span> instance            
</code></pre><p><code>IOLoop.confirable_base()</code>返回的就是<code>IOLoop</code>自身，所以进入<code>configured_class()</code></p>
<pre><code><span class="decorator">@classmethod</span>
<span class="function"><span class="keyword">def</span> <span class="title">configured_class</span><span class="params">(cls)</span>:</span>
    <span class="string">"""Returns the currently configured class."""</span>
    base = cls.configurable_base()
    <span class="keyword">if</span> cls.__impl_class <span class="keyword">is</span> <span class="keyword">None</span>:
        base.__impl_class = cls.configurable_default()
    <span class="keyword">return</span> base.__impl_class
</code></pre><p><code>IOLoop.configured_class()</code>返回的也是<code>IOLoop</code>这个类。</p>
<pre><code><span class="decorator">@classmethod</span>
<span class="function"><span class="keyword">def</span> <span class="title">configurable_default</span><span class="params">(cls)</span>:</span>
    <span class="keyword">if</span> hasattr(select, <span class="string">"epoll"</span>):
        <span class="keyword">from</span> tornado.platform.epoll <span class="keyword">import</span> EPollIOLoop
        <span class="keyword">return</span> EPollIOLoop
    <span class="keyword">if</span> hasattr(select, <span class="string">"kqueue"</span>):
        <span class="comment"># Python 2.6+ on BSD or Mac</span>
        <span class="keyword">from</span> tornado.platform.kqueue <span class="keyword">import</span> KQueueIOLoop
        <span class="keyword">return</span> KQueueIOLoop
    <span class="keyword">from</span> tornado.platform.select <span class="keyword">import</span> SelectIOLoop
    <span class="keyword">return</span> SelectIOLoop
</code></pre><p>在这里我们看到通过判断<code>select</code>模块有无 “epoll”，”kqueue” 属性在不同平台上实例化不同的<code>IOLoop</code>实例。<code>EPollIOLoop</code>、<code>KQueueIOLoop</code>和<code>SelectIOLoop</code>都继承于<code>PollIOLoop</code>并封装了统一的接口。在<code>PollIOLoop</code>中可以看到：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(self, fd, handler, events)</span>:</span>
    fd, obj = self.split_fd(fd)
    self._handlers[fd] = (obj, stack_context.wrap(handler))
    self._impl.register(fd, events | self.ERROR)

<span class="function"><span class="keyword">def</span> <span class="title">update_handler</span><span class="params">(self, fd, events)</span>:</span>
    fd, obj = self.split_fd(fd)
    self._impl.modify(fd, events | self.ERROR)

<span class="function"><span class="keyword">def</span> <span class="title">remove_handler</span><span class="params">(self, fd)</span>:</span>
    fd, obj = self.split_fd(fd)
    self._handlers.pop(fd, <span class="keyword">None</span>)
    self._events.pop(fd, <span class="keyword">None</span>)
    <span class="keyword">try</span>:
        self._impl.unregister(fd)
    <span class="keyword">except</span> Exception:
        gen_log.debug(<span class="string">"Error deleting fd from IOLoop"</span>, exc_info=<span class="keyword">True</span>)
</code></pre><p>如果要实现自己的 tornado 异步函数可以调用上面三个方法 在I<code>OLoop</code>中注册 fd 和 回调即可。<br>回到<code>__new__</code>函数，接下来就是创建实例<code>instance</code>然后初始化。<br>接下来我们到了重头戏——<code>start()</code></p>
<p><code>start</code>方法的实现在<code>PollIOLoop</code>，有近200行，不过可以分为几个部分</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(<span class="keyword">self</span>)</span>:</span>
    <span class="comment"># 初始化</span>
    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">_running:</span>
        raise <span class="constant">RuntimeError</span>(<span class="string">"IOLoop is already running"</span>)
    <span class="keyword">self</span>._setup_logging()
    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">_stopped:</span>
        <span class="keyword">self</span>._stopped = <span class="constant">False</span>
        <span class="keyword">return</span>
    old_current = getattr(<span class="constant">IOLoop</span>._current, <span class="string">"instance"</span>, <span class="constant">None</span>)
    <span class="constant">IOLoop</span>._current.instance = <span class="keyword">self</span>
    <span class="keyword">self</span>._thread_ident = thread.get_ident()
    <span class="keyword">self</span>._running = <span class="constant">True</span>

    ...

    <span class="symbol">try:</span>
        <span class="comment"># 下面就是事件循环</span>
        <span class="keyword">while</span> <span class="constant">True</span><span class="symbol">:</span>
            <span class="comment"># Prevent IO event starvation by delaying new callbacks</span>
            <span class="comment"># to the next iteration of the event loop.</span>
            with <span class="keyword">self</span>.<span class="symbol">_callback_lock:</span>
                callbacks = <span class="keyword">self</span>._callbacks
                <span class="keyword">self</span>._callbacks = []

            <span class="comment"># Add any timeouts that have come due to the callback</span>
            due_timeouts = []
            <span class="keyword">if</span> <span class="keyword">self</span>.<span class="symbol">_timeouts:</span>
                now = <span class="keyword">self</span>.time()
                <span class="keyword">while</span> <span class="keyword">self</span>.<span class="symbol">_timeouts:</span>
                    <span class="keyword">if</span> <span class="keyword">self</span>._timeouts[<span class="number">0</span>].callback is <span class="constant">None</span><span class="symbol">:</span>
                        <span class="comment"># The timeout was cancelled.  Note that the</span>
                        <span class="comment"># cancellation check is repeated below for timeouts</span>
                        <span class="comment"># that are cancelled by another timeout or callback.</span>
                        heapq.heappop(<span class="keyword">self</span>._timeouts)
                        <span class="keyword">self</span>._cancellations -= <span class="number">1</span>
                    elif <span class="keyword">self</span>._timeouts[<span class="number">0</span>].deadline &lt;= <span class="symbol">now:</span>
                        due_timeouts.append(heapq.heappop(<span class="keyword">self</span>._timeouts))
                    <span class="symbol">else:</span>
                        <span class="keyword">break</span>
                <span class="keyword">if</span> (<span class="keyword">self</span>._cancellations &gt; <span class="number">512</span>
                        <span class="keyword">and</span> <span class="keyword">self</span>._cancellations &gt; (len(<span class="keyword">self</span>._timeouts) <span class="prompt">&gt;&gt; </span><span class="number">1</span>))<span class="symbol">:</span>
                    <span class="comment"># Clean up the timeout queue when it gets large and it's</span>
                    <span class="comment"># more than half cancellations.</span>
                    <span class="keyword">self</span>._cancellations = <span class="number">0</span>
                    <span class="keyword">self</span>._timeouts = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="keyword">self</span>._timeouts
                                      <span class="keyword">if</span> x.callback is <span class="keyword">not</span> <span class="constant">None</span>]
                    heapq.heapify(<span class="keyword">self</span>._timeouts)

            <span class="comment"># 使用self._run_callback来执行回调</span>
            <span class="keyword">for</span> callback <span class="keyword">in</span> <span class="symbol">callbacks:</span>
                <span class="keyword">self</span>._run_callback(callback)
            <span class="comment"># 执行所有到期的 timeout</span>
            <span class="keyword">for</span> timeout <span class="keyword">in</span> <span class="symbol">due_timeouts:</span>
                <span class="keyword">if</span> timeout.callback is <span class="keyword">not</span> <span class="constant">None</span><span class="symbol">:</span>
                    <span class="keyword">self</span>._run_callback(timeout.callback)
            <span class="comment"># Closures may be holding on to a lot of memory, so allow</span>
            <span class="comment"># them to be freed before we go into our poll wait.</span>
            callbacks = callback = due_timeouts = timeout = <span class="constant">None</span>

        ... 
</code></pre><p>在循环的开始 先执行<code>self._callbacks</code>列表里面的回调函数还有 到达<code>deadline</code>的<code>timeout</code>。<code>timeout</code>类保存了一个<code>self.deadline</code>和<code>self.callback</code>并重载了<code>__lt__</code>和<code>__le__</code>方法，所以<code>IOLoop._timeouts</code>能使用优先队列<code>heap</code>来对它们排序，从而找出到期的<code>timeout</code>并执行它们的回调函数。<br>回到事件循环，执行完所有<code>callbacks</code>和<code>due_timeouts</code>后，<code>poll</code>终于出场了：</p>
<pre><code>...
<span class="comment"># 接上面</span>

        <span class="keyword">if</span> <span class="keyword">self</span>._callbacks:
            <span class="comment"># 如果在上面 self._callbacks 存在有callback，</span>
            <span class="comment"># poll 的等待时间设为0</span>
            poll_timeout = <span class="number">0.0</span>
            <span class="comment"># 如果在上面 self._timeouts 存在有timeout，</span>
            <span class="comment"># poll等待到最近timeout.deadline </span>
        elif <span class="keyword">self</span>._timeouts:
            poll_timeout = <span class="keyword">self</span>._timeouts[<span class="number">0</span>].deadline - <span class="keyword">self</span>.time()
            poll_timeout = max(<span class="number">0</span>, min(poll_timeout, _POLL_TIMEOUT))
        <span class="keyword">else</span>:
            <span class="comment"># No timeouts and no callbacks, so use the default.</span>
            poll_timeout = _POLL_TIMEOUT

        <span class="keyword">if</span> not <span class="keyword">self</span>._running:
            <span class="keyword">break</span>

        <span class="keyword">if</span> <span class="keyword">self</span>._blocking_signal_threshold is not None:
            <span class="comment"># clear alarm so it doesn't fire while poll is waiting for</span>
            <span class="comment"># events.</span>
            signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)

        <span class="keyword">try</span>:
            <span class="comment"># 终于 poll 了</span>
            event_pairs = <span class="keyword">self</span>._impl.poll(poll_timeout)
        except <span class="keyword">Exception</span> <span class="keyword">as</span> e:
            <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:
                <span class="keyword">continue</span>
            <span class="keyword">else</span>:
                raise

        <span class="keyword">if</span> <span class="keyword">self</span>._blocking_signal_threshold is not None:
            signal.setitimer(signal.ITIMER_REAL,
                             <span class="keyword">self</span>._blocking_signal_threshold, <span class="number">0</span>)

        <span class="keyword">self</span>._events.update(event_pairs)
        <span class="keyword">while</span> <span class="keyword">self</span>._events:
            fd, events = <span class="keyword">self</span>._events.popitem()
            <span class="keyword">try</span>:
                <span class="comment"># 获取注册 fd 的回调并执行</span>
                fd_obj, handler_func = <span class="keyword">self</span>._handlers[fd]
                handler_func(fd_obj, events)
            except (OSError, IOError) <span class="keyword">as</span> e:
                <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:
                    <span class="comment"># Happens when the client closes the connection</span>
                    pass
                <span class="keyword">else</span>:
                    <span class="keyword">self</span>.handle_callback_exception(<span class="keyword">self</span>._handlers.get(fd))
            except <span class="keyword">Exception</span>:
                <span class="keyword">self</span>.handle_callback_exception(<span class="keyword">self</span>._handlers.get(fd))
        fd_obj = handler_func = None

<span class="keyword">finally</span>:
    <span class="comment"># reset the stopped flag so another start/stop pair can be issued</span>
    <span class="keyword">self</span>._stopped = <span class="keyword">False</span>
    <span class="keyword">if</span> <span class="keyword">self</span>._blocking_signal_threshold is not None:
        signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)
    IOLoop._current.instance = old_current
    <span class="keyword">if</span> old_wakeup_fd is not None:
        signal.set_wakeup_fd(old_wakeup_fd)
</code></pre><p>总结一下，tornado 的<code>IOLoop</code>是 基于<code>poll</code>的事件驱动模型<code>IOLoop</code>是单线程的，避免了多进程/多线程模型上下文切换的损耗，在 IO 密集的情况下有很好的性能。但如果在<code>IOLoop</code>循环中 callback 的执行时间太长会阻塞掉整个 <code>IOLooop</code>，造成性能的急剧下降，所以在实践中要十分的注意。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/19/tornado-source-code-2/" data-id="cijleyex60001qi1ztqnmxn3c" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/19/tornado-source-code-2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-source-code-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/19/tornado-source-code-1/" class="article-date">
  <time datetime="2016-01-19T12:11:34.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/tornado-source-code-1/">tornado源码分析笔记(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tornado 是一个用 Python 实现的 Web 服务器框架，其最大的特点是使用异步非阻塞IO的处理方式来获取高负载和高性能。到底 Tornado 的底层是如何实现的呢？我们来一起看看。</p>
<p>注明一下，这里展示的 Tornado 版本为4.2.1，不同版本可能会有一些出入。</p>
<p>让我们从官方的 helloworld 开始我们的旅程：</p>
<p>helloworld.py:</p>
<pre><code>import tornado<span class="class">.httpserver</span>
import tornado<span class="class">.ioloop</span>
import tornado<span class="class">.options</span>
import tornado<span class="class">.web</span>

from tornado<span class="class">.options</span> import define, options

<span class="function"><span class="title">define</span><span class="params">(<span class="string">"port"</span>, default=<span class="number">8888</span>, help=<span class="string">"run on the given port"</span>, type=int)</span></span>


class <span class="function"><span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span></span>:
    def <span class="function"><span class="title">get</span><span class="params">(self)</span></span>:
        self.<span class="function"><span class="title">write</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span>


def <span class="function"><span class="title">main</span><span class="params">()</span></span>:
    tornado<span class="class">.options</span><span class="class">.parse_command_line</span>()
    application = tornado<span class="class">.web</span><span class="class">.Application</span>([
        (r<span class="string">"/"</span>, MainHandler),
    ])
    http_server = tornado<span class="class">.httpserver</span><span class="class">.HTTPServer</span>(application)
    http_server.<span class="function"><span class="title">listen</span><span class="params">(options.port)</span></span>
    tornado<span class="class">.ioloop</span><span class="class">.IOLoop</span><span class="class">.current</span>().<span class="function"><span class="title">start</span><span class="params">()</span></span>


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="function"><span class="title">main</span><span class="params">()</span></span>                         
</code></pre><p>Tornado 的基本框架是先实现处理各种模式的<code>RequestHandler</code>类，用这些模式和对应的 Handler 初始化一个<code>Application</code>类，再用这个<code>Application</code>类初始化一个<code>HTTPServer</code>，设置监听端口，再启动<code>IOLoop</code> 。<br>我们先来看<code>Application</code>:</p>
<p>web.py:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(httputil.HTTPServerConnectionDelegate)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, transforms=None,
                 **settings)</span>:</span>

        ...  <span class="comment"># 省略transform和ui模块的设置</span>

        self.handlers = []
        self.named_handlers = {}
        self.default_host = default_host
        self.settings = settings
        <span class="keyword">if</span> self.settings.get(<span class="string">"static_path"</span>):
            path = self.settings[<span class="string">"static_path"</span>]
            handlers = list(handlers <span class="keyword">or</span> [])
            static_url_prefix = settings.get(<span class="string">"static_url_prefix"</span>,
                                             <span class="string">"/static/"</span>)
            static_handler_class = settings.get(<span class="string">"static_handler_class"</span>,
                                                StaticFileHandler)
            static_handler_args = settings.get(<span class="string">"static_handler_args"</span>, {})
            static_handler_args[<span class="string">'path'</span>] = path
            <span class="keyword">for</span> pattern <span class="keyword">in</span> [re.escape(static_url_prefix) + <span class="string">r"(.*)"</span>,
                            <span class="string">r"/(favicon\.ico)"</span>, <span class="string">r"/(robots\.txt)"</span>]:
                handlers.insert(<span class="number">0</span>, (pattern, static_handler_class,
                                    static_handler_args))
        <span class="keyword">if</span> handlers:
            self.add_handlers(<span class="string">".*$"</span>, handlers)

        ...
</code></pre><p><code>Application</code>的初始化的工作主要是设置 transform , 加载 ui 模块，为静态文件设置<code>StaticFileHandler</code>，后面还有为 debug 模式设置 autoreload，最主要的还是调用<code>self.add_handlers(&quot;.*$&quot;, handlers)</code>来添加 handlers，</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span>:</span>
    <span class="string">"""Appends the given handlers to our handler list."""</span>
    <span class="keyword">if</span> <span class="keyword">not</span> host_pattern.endswith(<span class="string">"$"</span>):
        host_pattern += <span class="string">"$"</span>
    handlers = []

    <span class="comment"># 确保全部匹配的 handler 处于 self.handlers 的最后 </span>
    <span class="keyword">if</span> self.handlers <span class="keyword">and</span> self.handlers[-<span class="number">1</span>][<span class="number">0</span>].pattern == <span class="string">'.*$'</span>:
        self.handlers.insert(-<span class="number">1</span>, (re.compile(host_pattern), handlers))
    <span class="keyword">else</span>:
        self.handlers.append((re.compile(host_pattern), handlers))

    <span class="keyword">for</span> spec <span class="keyword">in</span> host_handlers:
        <span class="keyword">if</span> isinstance(spec, (tuple, list)):
            <span class="keyword">assert</span> len(spec) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)
            spec = URLSpec(*spec)
        handlers.append(spec)
        <span class="keyword">if</span> spec.name:
            <span class="keyword">if</span> spec.name <span class="keyword">in</span> self.named_handlers:
                app_log.warning(
                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>,
                    spec.name)
            self.named_handlers[spec.name] = spec
</code></pre><p>接下来我们看<code>HttpServer</code>类，它的初始化没什么好讲的，值得注意到一点是它以<code>self.request_callback</code>属性来保存<code>Application</code>类。直接来看<code>listen</code>方法<code>HttpServer</code>的 listen 方法直接继承自<code>TCPServer</code>的<code>listen</code>方法。</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>)</span>:</span>

        sockets = bind_sockets(port, address=address)
        self.add_sockets(sockets)
</code></pre><p>Socket 连接要经过 create -&gt; bind -&gt; listen 的三部曲。bind_sockets 函数走完了前面两步：就是创建 socket 并进行设置，然后 bind。因为输入的 address 可能对应多个IP地址，所以<code>bind_sockets</code>返回值为一个 socket 的列表。 我们来看<code>add_sockets</code>：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_sockets</span><span class="params">(self, sockets)</span>:</span>

        <span class="keyword">if</span> self.io_loop <span class="keyword">is</span> <span class="keyword">None</span>:
            self.io_loop = IOLoop.current()

        <span class="keyword">for</span> sock <span class="keyword">in</span> sockets:
            self._sockets[sock.fileno()] = sock
            add_accept_handler(sock, self._handle_connection,
                               io_loop=self.io_loop)
</code></pre><p>一开始先获得<code>IOLoop</code>实例，对于<code>IOLoop</code>是全局的单例，关于<code>IOLoop</code>的将在其他地方详述<code>add_accept_handler</code>用于设置 socket 接收到连接时的回调函数为<code>self._handle_connection</code>。先来看 <code>add_accept_handler</code>：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_accept_handler</span><span class="params">(sock, callback, io_loop=None)</span>:</span>

    <span class="keyword">if</span> io_loop <span class="keyword">is</span> <span class="keyword">None</span>:
        io_loop = IOLoop.current()

    <span class="function"><span class="keyword">def</span> <span class="title">accept_handler</span><span class="params">(fd, events)</span>:</span>

        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_DEFAULT_BACKLOG):
            <span class="keyword">try</span>:
                connection, address = sock.accept()
            <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:
                <span class="comment"># _ERRNO_WOULDBLOCK indicate we have accepted every</span>
                <span class="comment"># connection that is available.</span>
                <span class="keyword">if</span> errno_from_exception(e) <span class="keyword">in</span> _ERRNO_WOULDBLOCK:
                    <span class="keyword">return</span>
                <span class="comment"># ECONNABORTED indicates that there was a connection</span>
                <span class="comment"># but it was closed while still in the accept queue.</span>
                <span class="comment"># (observed on FreeBSD).</span>
                <span class="keyword">if</span> errno_from_exception(e) == errno.ECONNABORTED:
                    <span class="keyword">continue</span>
                <span class="keyword">raise</span>
            callback(connection, address)
    io_loop.add_handler(sock, accept_handler, IOLoop.READ)
</code></pre><p>在<code>add_accept_handler</code>向<code>io_loop</code>注册了 sock，在<code>IOLoop.READ</code>事件到来时的 调用<code>accept_handler</code>来处理 socket 事件。<code>accept_handler</code>就定义在<code>add_accept_handler</code>内部，可以看到其实就是<code>sock.accept()</code>获取连接的 socket 和 address，然后再调用回调函数，也就是<code>TCPServer. _handle_connection</code>:</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">_handle_connection</span><span class="params">(self, connection, address)</span>:</span>
        <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:

            ...  <span class="comment"># 处理ssl</span>

        <span class="keyword">try</span>:
            <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                stream = SSLIOStream(connection, io_loop=self.io_loop,
                                     max_buffer_size=self.max_buffer_size,
                                     read_chunk_size=self.read_chunk_size)
            <span class="keyword">else</span>:
                stream = IOStream(connection, io_loop=self.io_loop,
                                  max_buffer_size=self.max_buffer_size,
                                  read_chunk_size=self.read_chunk_size)
            future = self.handle_stream(stream, address)
            <span class="keyword">if</span> future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                self.io_loop.add_future(future, <span class="keyword">lambda</span> f: f.result())
        <span class="keyword">except</span> Exception:
            app_log.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="keyword">True</span>)
</code></pre><p>我们略去处理 ssl 的部分，在这里主要的内容就是将 socket 封装成<code>IOStream</code>类给上层处理。<code>handle_stream</code>方法在<code>HttpServer</code>中实现，返回<code>None</code>或一个<code>future</code>对象。关于<code>future</code>对象后面再细讲。</p>
<p>到此<code>Application</code>和<code>httpserver</code>就准备就绪，下面我们来看看 tornado 的核心——<code>IOLoop</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/19/tornado-source-code-1/" data-id="cijleyexe0002qi1zvnle38db" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/19/tornado-source-code-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python-captcha" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/06/python-captcha/" class="article-date">
  <time datetime="2016-01-06T13:18:32.000Z" itemprop="datePublished">2016-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/06/python-captcha/">使用Python做验证码识别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>平常我们上网经常遇到的验证码英文名为CAPTCHA， 这其实是一个非常炫酷的名字的缩写，全称为全自动区分计算机和人类的图灵测试（英语：Completely Automated Public Turing test to tell Computers and Humans Apart) 。看起来是不是很高大上啊，图灵测试都出来了。不过确实，对于识别验证码这种对人来说很容易的任务（普通验证码，非12306的）对于计算机来说可不简单。</p>
<h2 id="工具">工具</h2><p>有用的工具：</p>
<ul>
<li><a href="http://www.pythonware.com/products/pil/" target="_blank" rel="external">PIL</a>(Python Image Library)——图片处理库</li>
<li><a href="http://www.numpy.org/" target="_blank" rel="external">numpy</a>——矩阵运算</li>
<li><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="external">tesseract</a>——开源的ORC库</li>
<li><a href="http://scikit-learn.org/stable/index.html" target="_blank" rel="external">scikit-learn</a>——机器学习方面的集成包</li>
</ul>
<h2 id="分析验证码">分析验证码</h2><p>验证码也是有计算机生成的，所以不同的验证码有不同的处理方法。所以验证码识别的第一步是观察目标验证码的规律。这次面对的验证码张这样子</p>
<p><img src="http://7vzu7p.com1.z0.glb.clouddn.com/shot.png" alt=" "></p>
<p>一般来说第一步首先是要将验证码图片转换为二值图去除干扰信息，便于进一步处理。<br>观察分析验证码的字体都是同样的颜色，背景有横的或斜的条纹。直接二值化效果并不好。但是字符之间是没有粘连的，所以我们可以利用这一点提取出字符。</p>
<h2 id="预处理">预处理</h2><h3 id="寻找字符像素">寻找字符像素</h3><p>首先第一步是提取出字符的颜色也就是RGB值，观察到字符的颜色相同，占整个验证码图片的比例基本上是差不多的。所以我们可以通过分析像素的直方图找出字符的像素值出来。不过我偷懒没用这样的方法，因为图片开头都是横向的条纹，所以我就直接从左往右扫描图片横向中线的像素值，找出像素值突变的地方就可以找到字符的像素值了。</p>
<h3 id="FloodFill算法提取字符">FloodFill算法提取字符</h3><p>Flood fill算法是从一个区域中提取若干个连通的点与其他相邻区域区分开（或分别染成不同颜色）的经典算法。处理这种没有粘连字符或者粘连但是字符每个颜色不一样的验证码效果拔群。多说无益，看图就明白了</p>
<p><img src="http://7vzu7p.com1.z0.glb.clouddn.com/floodfill4.gif" alt=" "><br><img src="http://7vzu7p.com1.z0.glb.clouddn.com/floodfill8.gif" alt=" "></p>
<p>FloodFill最简单的实现是用递归</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">flood_fill</span><span class="params">(img, x0, y0, blank_color, color_to_fill, cmp_func)</span>:</span> 
    pix = img.load()
    pix[x0, y0] = color_to_fill
    offsets = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]
    <span class="keyword">for</span> xoffset, yoffset <span class="keyword">in</span> offsets:
        x, y = x0 + xoffset, y0 + yoffset
        <span class="keyword">try</span>:
            <span class="keyword">if</span> cmp_func(pix[x, y], blank_color):
                flood_fill(img, x, y, blank_color)
        <span class="keyword">except</span> IndexError:
            <span class="keyword">pass</span>
</code></pre><p>不过python不支持尾递归优化，所以运行时回出现异常提示到达最大递归限制。所以改用基于队列的广度优先搜索<br>实现</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">flood_fill2</span><span class="params">(img, x0, y0, blank_color, color_to_fill, cmp_func)</span>:</span>
    pix = img.load()
    visited = set()
    q = queue.Queue()
    q.put((x0, y0))
    visited.add((x0, y0))
    offsets = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>)]
    <span class="keyword">while</span> <span class="keyword">not</span> q.empty():
        x, y = q.get()
        pix[x, y] = color_to_fill
        <span class="keyword">for</span> xoffset, yoffset <span class="keyword">in</span> offsets:
            x1, y1 = x + xoffset, y + yoffset
            <span class="keyword">if</span> (x1, y1) <span class="keyword">in</span> (visited):
                <span class="keyword">continue</span>  <span class="comment"># 已经访问过了</span>
            visited.add((x1, y1))
            <span class="keyword">try</span>:
                <span class="keyword">if</span> cmp_func(pix[x1, y1], blank_color):
                       q.put((x1, y1))
            <span class="keyword">except</span> IndexError:
                <span class="keyword">pass</span>
    <span class="keyword">return</span> visited
</code></pre><h3 id="字符分割">字符分割</h3><p>字符串的分割也是非常重要的一步，对于复杂的验证码，目前还没有非常有效的字符串分割方法。 对于不粘连并且字符之间没有重叠的字符串直接在上下左右四个方向扫描整行或整列是否空白来分割字符</p>
<p><img src="http://7vzu7p.com1.z0.glb.clouddn.com/rrr.png" alt=" "></p>
<p>对于字符间有重叠的，如下图的2和F。</p>
<p><img src="http://7vzu7p.com1.z0.glb.clouddn.com/linkchar.png" alt=""></p>
<p>一种方法是使用斜向的切割法，但更好的方法还是统计x坐标上的黑白像素占比，在字符分隔处会有白像素占比的波谷。根据这个波谷的来分割图片。</p>
<h3 id="标准化(normalize)">标准化(normalize)</h3><p>这一步将切割出来的字符摆正并且统一成一样的大小</p>
<p>摆正字符的方法是使用旋转卡壳算法。即从 -30度 ~ 30度旋转图片，检测字符间距，取最小间距对应的角度。</p>
<p><img src="http://7vzu7p.com1.z0.glb.clouddn.com/trible91.png" alt=""></p>
<p>最后在四周填充像素，把所以字符图片统一成一样的尺寸。</p>
<h3 id="识别">识别</h3><h4 id="Tesseract">Tesseract</h4><p>识别方面可以使用ORC库<a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="external">tesseract</a></p>
<p>在安装tesseract后 python使用<a href="https://pypi.python.org/pypi/pytesseract/0.1" target="_blank" rel="external">pytessract</a>方便的调用tesseractF</p>
<pre><code><span class="keyword">import</span> pytesseract
<span class="keyword">from</span> <span class="type">PIL</span> <span class="keyword">import</span> <span class="type">Image</span>

img = <span class="type">Image</span>.open(<span class="string">"captcha.png"</span>)

<span class="literal">result</span> = pytesseract.image_to_string(img, config='-psm <span class="number">7</span>')
</code></pre><p>不过经测试tesseract的对于标准的印刷体的英文识别效果还是可以的，但若有旋转扭曲等扰动等话识别率就不是很高了。不过tesseract通过训练自己的识别模型来提高识别率。</p>
<h4 id="机器学习">机器学习</h4><p>另外一个看起来更高大上的方法是应用机器学习的方法来做识别，常用的有SVM和神经网络。</p>
<p>python下机器学习的库首推<a href="http://scikit-learn.org/stable/index.html" target="_blank" rel="external">scikit-learn</a>。scikit-learn里面集成了各种常用的识别模型，降纬，聚类等算法，还要非常棒的文档，可以说是机器学习方面的百宝箱。</p>
<p>使用scikit-learn训练验证码识别模型这事。。。还是先挖个坑，下回再填吧</p>
<hr>
<h3 id="Reference">Reference</h3><p><a href="http://drops.wooyun.org/tips/141" target="_blank" rel="external">http://drops.wooyun.org/tips/141</a><br><a href="http://drops.wooyun.org/tips/6313" target="_blank" rel="external">http://drops.wooyun.org/tips/6313</a><br><a href="http://pillow.readthedocs.org/en/3.0.x/reference/Image.html" target="_blank" rel="external">http://pillow.readthedocs.org/en/3.0.x/reference/Image.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/06/python-captcha/" data-id="cijleyexh0004qi1zf5bcg60r" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/06/python-captcha/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android-studio-tess-two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/02/android-studio-tess-two/" class="article-date">
  <time datetime="2016-01-02T09:49:15.000Z" itemprop="datePublished">2016-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/02/android-studio-tess-two/">在Android Studio中使用tess-Two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Tesseract_&amp;_tess-two">Tesseract &amp; tess-two</h2><p><a href="http://code.google.com/p/tesseract-ocr/" target="_blank" rel="external">Tesseract</a>是一个开源的OCR(optical character Recognition)库，最初由惠普公司开发，然后开源之后由google维护。使用Tesseract可以从图片中识别出文字。Tesseract支持多种文字，还可以针对目标训练自己的识别模型，可以说大大方便了开发者。tess-two是Tesseract在Android平台上的移植。更多信息参阅<a href="https://github.com/rmtheis/tess-two" target="_blank" rel="external">tess-two主页</a></p>
<h2 id="tess-two在Android_Studio的配置">tess-two在Android Studio的配置</h2><h4 id="1-_下载安装Android_NDK">1. 下载安装Android NDK</h4><h4 id="2-_下载解压tess-two或者直接git_clone">2. 下载解压<a href="https://github.com/rmtheis/tess-two" target="_blank" rel="external">tess-two</a>或者直接git clone</h4><h4 id="3-_使用NDK编译解压出来的_tess-two_下的_tess-two_文件夹">3. 使用NDK编译解压出来的 tess-two 下的 tess-two 文件夹</h4><pre><code><span class="keyword">cd</span> tess-<span class="keyword">two</span>/tess-<span class="keyword">two</span>
ndk-build
</code></pre><h4 id="4-_配置Android_Studio">4. 配置Android Studio</h4><p>在你的项目目录下新建一个libraries的文件夹，将NDK编译好的tess-two/tess-two目录复制到libraries下。<br>在libraries/tess-two目录下新建一个 build.gradle 的文件。将下面的内容复制进去</p>
<pre><code>apply plugin: <span class="string">'android-library'</span>

<span class="keyword">buildscript</span> {
    <span class="keyword">repositories</span> {
        mavenCentral()
    }
    <span class="keyword">dependencies</span> {
        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:1.5.0'</span>   <span class="comment">// 根据你的gradle版本进行调整</span>
    }
}

android {
    compileSdkVersion <span class="number">23</span>             <span class="comment">// 根据你的项目进行调整</span>
    buildToolsVersion <span class="string">"23.0.2"</span>       <span class="comment">// 根据你的项目进行调整</span>

    defaultConfig {
        minSdkVersion <span class="number">15</span>             <span class="comment">// 根据你的项目进行调整</span>
        targetSdkVersion <span class="number">23</span>          <span class="comment">// 根据你的项目进行调整</span>
    }

    <span class="keyword">sourceSets</span>.main {
        manifest.srcFile <span class="string">'AndroidManifest.xml'</span>
        java.srcDirs = [<span class="string">'src'</span>]
        resources.srcDirs = [<span class="string">'src'</span>]
        res.srcDirs = [<span class="string">'res'</span>]
        jniLibs.srcDirs = [<span class="string">'libs'</span>]
    }
}
</code></pre><p>然后在项目目录下的 setting.gradle 文件下加入一行</p>
<pre><code><span class="keyword">include</span> <span class="string">':libraries:tess-two'</span>
</code></pre><p>在项目目录下的app/build.gradle 文件中的 dependencies 部分加入一行 <code>compile project(&#39;:libraries:tess-two&#39;)</code></p>
<pre><code><span class="keyword">dependencies</span> {
    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])
    testCompile <span class="string">'junit:junit:4.12'</span>
    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.1.0'</span>
    ....

    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':libraries:tess-two'</span>)
}
</code></pre><h4 id="使用Tess-two">使用Tess-two</h4><p>tess-two 的识别需要提供一个tessdata的文件夹，可以在<a href="http://code.google.com/p/tesseract-ocr/" target="_blank" rel="external">http://code.google.com/p/tesseract-ocr/</a>中找到。  </p>
<p>这里提供一个简单的 demo </p>
<pre><code><span class="keyword">import</span> com.googlecode.tesseract.android.<span class="type">TessBaseAPI</span>;


public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AppCompatActivity</span> {</span>

    <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">String</span> <span class="type">SD_PATH</span>= <span class="type">Environment</span>.getExternalStorageDirectory().getPath();

    <span class="keyword">private</span> <span class="type">Button</span> button;
    <span class="keyword">private</span> <span class="type">TextView</span> textView;
    <span class="keyword">private</span> <span class="type">EditText</span> editText;

    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {
        <span class="keyword">super</span>.onCreate(savedInstanceState);
        setContentView(<span class="type">R</span>.layout.activity_main);

        button = (<span class="type">Button</span>) findViewById(<span class="type">R</span>.id.button);
        textView = (<span class="type">TextView</span>) findViewById(<span class="type">R</span>.id.textView);

        button.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() {
            <span class="annotation">@Override</span>
            public void onClick(<span class="type">View</span> v) {

                <span class="type">TessBaseAPI</span> baseApi = <span class="keyword">new</span> <span class="type">TessBaseAPI</span>();
                <span class="comment">// 指定语言集，sd卡根目录下放置Tesseract的tessdata文件夹   </span>
                baseApi.init(<span class="type">SD_PATH</span>, <span class="string">"eng"</span>);
                <span class="comment">// 设置psm模式</span>
                baseApi.setPageSegMode(<span class="type">TessBaseAPI</span>.<span class="type">PageSegMode</span>.<span class="type">PSM_SINGLE_LINE</span>);

                editText = (<span class="type">EditText</span>) findViewById(<span class="type">R</span>.id.editText);
                <span class="type">String</span> img = editText.getText().toString();
                <span class="comment">// 设置图片</span>
                baseApi.setImage(<span class="keyword">new</span> <span class="type">File</span>(<span class="type">SD_PATH</span> + img));
                <span class="comment">// 获取结果</span>
                <span class="keyword">final</span> <span class="type">String</span> result = baseApi.getUTF8Text();
                textView.setText(result);
                <span class="comment">// 释放内存</span>
                baseApi.clear();
                baseApi.end();

            }
        });
    }
}
</code></pre><hr>
<p>参考</p>
<p><a href="https://coderwall.com/p/eurvaq/tesseract-with-andoird-and-gradle" target="_blank" rel="external">https://coderwall.com/p/eurvaq/tesseract-with-andoird-and-gradle</a><br><a href="http://www.kaustubhraghavan.com/ocr.html" target="_blank" rel="external">http://www.kaustubhraghavan.com/ocr.html</a><br><a href="http://hellosure.github.io/ocr/2014/10/11/tesseract-ocr/" target="_blank" rel="external">http://hellosure.github.io/ocr/2014/10/11/tesseract-ocr/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/02/android-studio-tess-two/" data-id="cijleyexp0008qi1zorg6wttl" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/02/android-studio-tess-two/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-migrate-to-hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/22/migrate-to-hexo/" class="article-date">
  <time datetime="2015-09-22T11:57:54.000Z" itemprop="datePublished">2015-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/22/migrate-to-hexo/">博客迁移到Hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在学nodejs， 顺便也把博客从pelican换成<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a>。Hexo的安装配置都非常方便，易用性很好，非常推荐。后面也不想再折腾了，拿这精力时间多写些博客才是正道。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2015/09/22/migrate-to-hexo/" data-id="cijleyexk0006qi1zw7guhxn7" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2015/09/22/migrate-to-hexo/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android-package-cmd" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/05/android-package-cmd/" class="article-date">
  <time datetime="2015-03-04T16:00:00.000Z" itemprop="datePublished">2015-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/05/android-package-cmd/">命令行编译打包android应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在eclipse中点击一下就能将android项目一键构建，但在这个过程中发生了什么？我们亲手用命令行来实践一下吧.</p>
<h2 id="构建流程">构建流程</h2><p>先上一张google官方的构建流程图<br><img src="http://7vzu7p.com1.z0.glb.clouddn.com/Android_build.png" alt="build process"></p>
<ul>
<li>Android Asset Packaging Tool (aapt) 将文资源件如AndroidManifest.xml还有其他Activity的XML文件编译成二进制文件。将他们打包和生成R.java文件</li>
<li>aidl将.aidl接口文件转换为java代码</li>
<li>将所有的java代码包括 R.java and aidl生成的java代码编译成.class文件</li>
<li>用dx将.class文件编译成Dalvik虚拟机使用的字符码</li>
<li>将所有的文件打包成.apk文件，包括编译的资源包，未编译的资源文件，.dex文件</li>
<li>用debug或release key对apk文件签名。</li>
<li>发布应用</li>
</ul>
<h2 id="命令行构建">命令行构建</h2><p>下面我们就来用命令行实践一下,我所使用的sdk版本是android-sdk_r24.0.2-linux<br>首先新建一个Android应用项目<br>    android create project –target 19 –name TestApp –path ~/workspace/TestApp –activity MainActivity –package com.example.testapp</p>
<h3 id="使用aapt生成R-java和编译的资源包">使用aapt生成R.java和编译的资源包</h3><p>aapt在sdk中的build-tools中找到，从build-tools中选最新的版本的aapt<br>appt的使用方法</p>
<pre><code>aapt package -f -M ${manifest.file}   
-<span class="ruby"><span class="constant">F</span> <span class="variable">${</span>packaged.resource.file}     
</span>-<span class="ruby"><span class="constant">I</span> <span class="variable">${</span>path.to.android-jar.library}   
</span>-<span class="ruby"><span class="constant">S</span> <span class="variable">${</span>android-resource-directory}    
</span>[-m -J ${folder.to.output.the.R.java}]
</code></pre><p>实践：</p>
<pre><code>mkdir <span class="regexp">~/workspace/</span>TestApp/gen
.<span class="regexp">/aapt package -f -M ~/</span>workspace<span class="regexp">/TestApp/</span>AndroidManifest.xml \  
-F <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>resources.arsc \  
-I <span class="regexp">~/Android/</span>SDK<span class="regexp">/platforms/</span>android-<span class="number">21</span>/android.jar \  
-S <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/res/</span>   \  
-m -J <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/gen/</span>
</code></pre><h3 id="使用aidl命令把-aidl转成-java文件">使用aidl命令把.aidl转成.java文件</h3><pre><code><span class="title">aidl</span> -p <span class="variable">${android-framework}</span> -I <span class="variable">${srcdir}</span> dir=<span class="string">"<span class="variable">${srcdir}</span>"</span> <span class="variable">${.aidl files}</span>
</code></pre><p>这里我们没有.aidl文件，所以跳过</p>
<h3 id="编译-java文件">编译.java文件</h3><p>使用javac编译所有的.java文件</p>
<pre><code>mkdir <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>classes  
javac -encoding UTF-<span class="number">8</span> -source <span class="number">1.6</span> -target <span class="number">1.6</span> \  
-bootclasspath  <span class="regexp">~/Android/</span>SDK<span class="regexp">/platforms/</span>android-<span class="number">21</span>/android.jar \  
-d <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>classes \   
<span class="regexp">~/workspace/</span>TestApp<span class="regexp">/src/</span>com<span class="regexp">/example/</span>testapp<span class="comment">/*.java \  
~/workspace/TestApp/gen/com/example/testapp/R.java</span>
</code></pre><h3 id="生成dex文件">生成dex文件</h3><p>生成dex文件的工具是dx，跟aapt在同一目录。<br>dx用法：</p>
<pre><code><span class="title">dx</span> -–dex --dump-to <span class="variable">${output.dex.file}</span>  --core-library <span class="variable">${compiled.classes.directory}</span> 
</code></pre><p>实践：</p>
<pre><code>.<span class="regexp">/dx --dex --dump-to ~/</span>workspace<span class="regexp">/TestApp/</span>bin/classes.dex \  
--core-library  <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>classes
</code></pre><p>注意在我使用的build-tools/21.1.2中的dx还不兼容使用jdk 8及以上版本，所以在用javac编译时需指定source和target为1.6或1.7。这点需要注意，不然会出现下面的异常</p>
<pre><code>UNEXPECTED TOP-LEVEL <span class="string">EXCEPTION:</span>
</code></pre><h3 id="打包所有文件成apk文件">打包所有文件成apk文件</h3><p>打包所有文件成apk文件使用的工具是apkbuilder，不过在较新的android sdk中取消了这个工具，不过apkbuilder只是个批处理文件，我们可以自己生成它。在sdk/tools目录中：</p>
<pre><code><span class="keyword">cat</span> android | sed -<span class="keyword">e</span> 's/com.android.sdkmanager.Main/com.android.sdklib.build.ApkBuilderMain/<span class="keyword">g</span>' &gt; apkbuilder
chmod a+x apkbuilder
</code></pre><p>  详情查看stackoverflow的<a href="http://stackoverflow.com/questions/19273237/android-build-fails-no-such-file-or-directory-apkbuilder" target="_blank" rel="external">这个问答</a><br>  apkbuilder用法：</p>
<pre><code>apkbuilder  <span class="label">${output</span>.apk.<span class="keyword">file</span>} -<span class="keyword">u</span> -z  <span class="label">${packagedresource</span>.<span class="keyword">file</span>} -f  <span class="label">${dex</span>.<span class="keyword">file</span>}
</code></pre><p>  实践：</p>
<pre><code>mkdir <span class="regexp">~/workspace/</span>TestApp/build  
.<span class="regexp">/apkbuilder ~/</span>workspace<span class="regexp">/TestApp/</span>build/TestApp-unsigned.apk  -u \  
-z <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>resources.arsc \  
-f <span class="regexp">~/workspace/</span>TestApp<span class="regexp">/bin/</span>classes.dex
</code></pre><h3 id="签名">签名</h3><p>apk需要正确的签名才能在android系统上安装，要签名apk就需要密钥key。生成key使用jdk中的keytool生成密钥证书</p>
<pre><code>keytool -genkeypair -<span class="keyword">alias</span> <span class="variable">${</span>别名} -keyalg <span class="constant">RSA</span> -keystore <span class="variable">${</span>keystore文件的路径+文件名}.keystore
</code></pre><p>实践：</p>
<pre><code>keytool -genkeypair -<span class="type">alias</span> <span class="string">"testkey"</span> -keyalg <span class="string">"RSA"</span> -keystore <span class="string">"test.keystore"</span> 
</code></pre><p>输入之后回答一堆问题之后就会生成.keystore文件<br>在debug的时候可以使用googleg提供的debug key，debug证书存放可以在$HOME/.android/debug.keystore中。<br>下一步是使用jarsigner给apk文件签名</p>
<pre><code><span class="title">jarsigner</span>  -keystore <span class="variable">${keystore}</span> -storepass  <span class="variable">${keystore.password}</span> -keypass <span class="variable">${keypass密钥别名密码}</span> -signedjar <span class="variable">${signed.apkfile}</span> <span class="variable">${unsigned.apkfile}</span> <span class="variable">${keyalias密钥别名}</span>
</code></pre><p>实践：</p>
<pre><code>jarsigner -keystore test<span class="class">.keystore</span> -storepass <span class="number">1234567890</span> -keypass <span class="number">1234567890</span> -signedjar \  
~/workspace/TestApp/build/TestApp-signed<span class="class">.apk</span> \  
~/workspace/TestApp/buildTestApp-unsigned<span class="class">.apk</span> testkey
</code></pre><h2 id="一步到位">一步到位</h2><p>由上可见，apk的构建非常的繁杂。不过好在android应用在创建的时候就已经配置好ant自动构建脚本了。在项目主目录下直接</p>
<pre><code><span class="title">ant</span> <span class="built_in">debug</span>
</code></pre><p>就可在bin下生成debug模式的apk<br>生产release使用</p>
<pre><code><span class="keyword">ant</span> release
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2015/03/05/android-package-cmd/" data-id="cijleyewy0000qi1zs6p5kf3b" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2015/03/05/android-package-cmd/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-latex-thesis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/02/latex-thesis/" class="article-date">
  <time datetime="2015-03-01T16:00:00.000Z" itemprop="datePublished">2015-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/02/latex-thesis/">使用LaTex写毕业论文</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>临近毕业，又是大四狗们忙着写毕业论文的时候了。写论文烦，论文的排版更烦，要对照着论文格式要求，调整位置、大小、字体等细节，还有引用、目录、注脚、参考文献之类的。使用word对论文进行排版有着诸多的不便，那有没有其他更好的方法呢？今天我就来介绍一下使用latex对论文排版的方法。</p>
<h2 id="什么是LaTex">什么是LaTex</h2><blockquote>
<p>LaTeX是一种基于TeX的排版系统，由美国电脑学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p>
</blockquote>
<p>以上是wiki上的解释。总的来说，LaTex是一套排版系统，与word那种所见即所得对排版方式不太，用LaTex排版更像是写程序一样，将想要的排版效果用指令写出来，再通过LaTex编译成文档。简单来说，你只要按照要求撰写tex文件，就能够通过LaTex生成排版好的pdf文件。<br>有些人可能听到写程序就头大了，其实使用命令来排版的好处正是我们可以将各种版式做成模板文件，使用者只要调用模板即可，完全不用去处理字体样大小、位置，目录生成，图片公式序号等诸多细节，使我们专注于内容。更多关于LaTex和word的比较<a href="http://zzg34b.w3.c361.com/homepage/compareWord.htm" target="_blank" rel="external">这篇文章</a>有很详细的论述。现在使用LaTex听起来是不是很诱人？不过好处也不是白给的，就我的实践来说，LaTex还是有不足之处：</p>
<ol>
<li>某些项目如表格，图形比word更加复杂</li>
<li>所见非所得，有错误的话需要重新编译，耗时间</li>
<li>有一定的门槛，需要一定的学习才能使用</li>
</ol>
<p>综上所述，我认为学习使用LaTex还是有个不错的选择，LaTex也是可以用来做简历，PPT等文档的。本文的目的也是希望用一些指导来降低LaTex学习使用上的难度。</p>
<h2 id="TexLive的安装">TexLive的安装</h2><p>LaTex是不支持中文，目前支持中文比较好的发行版是xelatex，安装TexLive就有了。由于大部分人使用的是windows操作系统，所以这里讲解windows下TexLive的安装。</p>
<ol>
<li>首先我们去<a href="http://tug.org/texlive/acquire-netinstall.html" target="_blank" rel="external">http://tug.org/texlive/acquire-netinstall.html</a>下载Texlive安装器 install-tl-windows.exe 。</li>
<li>运行install-tl-windows.exe进入安装界面，选择要安装方案<br>TexLive全部的安装包有4G，里面有许多其他国家的语言包我们用不着的，所以出现的第一个对话窗选择Custom install。<br><img src="http://7vzu7p.com1.z0.glb.clouddn.com/texlive_install1.PNG" alt="安装界面"><br>点击“进一步定制”右边的“修改”，取消掉一些语言和包<br><img src="http://7vzu7p.com1.z0.glb.clouddn.com/texlive_install2.PNG" alt="此处输入图片的描述"><br>以上是我的选择，总大小在3G，这个方案应该还有再精简的空间，不过我也没精力再去实验了。</li>
<li>等待下载安装完成即可。</li>
</ol>
<h2 id="安装编辑器">安装编辑器</h2><p>工欲善其事，必先利其器。TexLive自带的编辑器TeXworks功能太少，我们换一个更强大的编辑器TexMaker。TexMaker功能强大，对于公式表格等都有很好的支持。<a href="http://7x2vvx.com1.z0.glb.clouddn.com/texmakerwin32usb.zip" target="_blank" rel="external">[点我下载]</a>直接解压运行文件夹里面的texmaker即可使用。</p>
<h2 id="学习LaTex">学习LaTex</h2><p>使用LaTex没有一点基础是不行的，但我们也无需成为一个LaTex的高手，除非是做科研的，那个时间成本可是很大的，一些基本入门教程，遇到问题勤搜索就可以了。下面是一些不错的基础教程推荐给大家。<br><a href="http://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="external">一份其实很短的 LaTeX 入门文档</a><br><a href="http://read.pudn.com/downloads64/doc/224777/lshort412.pdf" target="_blank" rel="external">LATEX 2ε 入门指南</a><br><a href="ftp://cs2.swfu.edu.cn/pub/resources/Books/TeX/xetex-tutorial.pdf" target="_blank" rel="external">XeLaTEX/LATEX 中文排版之胡言乱语</a></p>
<h2 id="模板">模板</h2><p>自制模板是一件十分复杂麻烦的事情，不过好在很多高校都有LaTex论文模板，这里推荐一个网站<a href="http://www.latexstudio.net/" target="_blank" rel="external">LaTexStudio</a>，上面收集有很多高校的论文模板和教程资源。<br><a href="http://www.latexstudio.net/category/latex-templates/internal-university-tex-template/" target="_blank" rel="external">模板点我直达</a><br>一般下载文件里面都会说明使用方法的，跟着做就是了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2015/03/02/latex-thesis/" data-id="cijleyexn0007qi1z8cylunzq" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2015/03/02/latex-thesis/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-pelican-configure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/01/pelican-configure/" class="article-date">
  <time datetime="2015-02-28T16:00:00.000Z" itemprop="datePublished">2015-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/01/pelican-configure/">Pelican的配置与使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://sineyuan.github.io/blog_setup.html">上一篇教程</a>讲了如何使用GithubPage和Pelican来搭建个人静态博客，这篇是上一篇的继续，主要说明一下Pelican的配置和在写博客过程中遇到的问题及其解决方法。闲话不说，我们继续。</p>
<h2 id="Pelican插件的使用">Pelican插件的使用</h2><p>大部分的时候Pelican提供的功能是不能够满足我们的需求的，比如Google的Analytical，sitemap，评论系统，导航页面等。这时就需要安装相应的插件来提供这些功能了。其实Pelican插件的安装使用非常简单，Pelican的全部插件都在<a href="https://github.com/getpelican/pelican-plugins" target="_blank" rel="external">pelican-plugins</a>这个项目上，先从github上clone这个项目</p>
<pre><code>cd blog  
git <span class="keyword">clone</span> <span class="title">git</span>://github.com/getpelican/pelican-plugins.git
</code></pre><p>然后需要什么差件，就在主目录下的配置文件pelicanconf.py中声明并设置就可以了，例如在要使用设置Sitemap插件，就在pelicanconf.py中设置如下</p>
<p><pre><code>PLUGIN_PATH=u”pelican-plugins”              #指定插件源文件的存放目录<br>PLUGINS = [‘summary’,’sitemap’,’neighbors’] #[]里面的是启用的插<br># 配置sitemap 插件<br>SITEMAP = {<br>    “format”: “xml”,<br>    “priorities”: {<br>        “articles”: 0.7,<br>        “indexes”: 0.5,<br>        “pages”: 0.3,<br>    },<br>    “changefreqs”: {<br>        “articles”: “monthly”,<br>        “indexes”: “daily”,<br>        “pages”: “monthly”,<br>    }</code></pre></p>
<p>}<br>}<br>在<a href="https://github.com/getpelican/pelican-plugins" target="_blank" rel="external">pelican-plugins</a>项目主页上有这些插件的功能简介</p>
<h2 id="Pelican主题">Pelican主题</h2><p>同样，Pelican的主题也有一个主页：<a href="https://github.com/getpelican/pelican-themes" target="_blank" rel="external">pelican-themes</a>，同样先clone下来</p>
<pre><code>git <span class="keyword">clone</span> <span class="title">https</span>://github.com/getpelican/pelican-themes.git
</code></pre><p>之后cd进pelican-themes中，想装什么主题就用pelican-themes -i语句安装</p>
<pre><code>cd pelican-themes  
pelican-themes -<span class="tag">i</span> bootstrap2
</code></pre><p>最后在pelicanconf.py中添加下面的语句设置安装过的主题，最后make一下就可以了</p>
<pre><code><span class="setting">THEME = <span class="value"><span class="string">'bootstrap2'</span></span></span>
</code></pre><p>能够成功的前提是在主题的文件夹中源文件确实存在，有些主题文件夹是空的，这时只需要去到相应的项目主页clone下来就可以了。<br>在<a href="http://pelicanthemes.com/" target="_blank" rel="external">http://pelicanthemes.com/</a>这个网页上可以预览到所有的主题，喜欢的就clone下来吧。</p>
<h2 id="第三方评论系统">第三方评论系统</h2><p>因为GithubPage是静态博客，所以不支持评论系统，不过我们可以通过Disqus解决这个问题。Disqus是一家第三方社会化评论系统，主要为网站主提供评论托管服。首先要到<a href="https://disqus.com/" target="_blank" rel="external">Disqus</a>上注册一个帐号，注册完后点击右上角的齿轮，在弹出的选项中点击add Disqus to Site,在弹出的页面中注册你的博客名。完成注册后，回到小齿轮那就会多了个admin选项，点进去，在跳出的页面中我们就可以管理你博客的评论了。在Settings=&gt;Site Identity中可以看到shortname，请记下来。</p>
<p></p><p style="text-align:center"><img src="http://7vzu7p.com1.z0.glb.clouddn.com/disqus_setting.png"></p><br>然后在pelicanconf.py文件中添加<p></p>
<pre><code><span class="setting">DISQUS_SITENAME = <span class="value"><span class="string">"shortname"</span></span></span>
</code></pre><p>然后重新make一遍，上传就会出现评论了。</p>
<h2 id="文章中的图片">文章中的图片</h2><p>在markdown中想要插入图片很简单</p>
<pre><code>!<span class="attr_selector">[alt tag]</span>\(<span class="attribute">http</span>:<span class="comment">//url/to/img.png)</span>
</code></pre><p>但问题是如何指定我想要的图片的url<br>一种方法是上传图片到github中，再将url指向github中的图片。<br>比如说在output文件夹中新建一个img文件夹，将图片放进去，在文章中引用的url路径为：</p>
<pre><code><span class="symbol">https:</span>/<span class="regexp">/raw.github.com/username</span><span class="regexp">/projectname/branch</span><span class="regexp">/path/to</span><span class="regexp">/img.png     </span>
</code></pre><p>不过github的空间有限，只有300M，所以另一种方法推荐使用专业的图床</p>
<h2 id="数学公式">数学公式</h2><p>有时候博文中需要一些数学公式，这时只要在添加插件render_math,之后就可以用latex书写公式了</p>
<pre><code><span class="setting">PLUGINS = <span class="value">[<span class="string">"render_math"</span>]</span></span>
</code></pre><p>在文章中插入latex：  </p>
<pre><code>$<span class="variable">$e</span>^{i\pi} + <span class="number">1</span> = <span class="number">0</span>$$
</code></pre><p>欧拉公式<br>$$e^{i\pi} + 1 = 0$$</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2015/03/01/pelican-configure/" data-id="cijleyexj0005qi1z1xpfmrd1" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2015/03/01/pelican-configure/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-setup-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/28/setup-blog/" class="article-date">
  <time datetime="2015-02-27T16:00:00.000Z" itemprop="datePublished">2015-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/28/setup-blog/">用Pelican+GithubPage搭建个人静态博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要写博客">为什么要写博客</h2><p>关于为什么要写博客，其实刘未鹏写过两篇非常好的博文：<a href="http://mindhacks.cn/2009/02/09/writing-is-better-thinking/" target="_blank" rel="external">书写是为了更好的思考</a>，<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">为什么你应该（从现在开始就）写博客</a>，希望大家都能看一看。其实我知道我这个博客一年除了我之外访客可能没有多少个，所以这里更多的是关于自己思考的一个整理和学习的记录，如果能够帮到其他的人，那对我来说也是十分开心的事情了。</p>
<h2 id="技术选择">技术选择</h2><p>搭建博客的方法有很多，主流的是使用wordpress，不过对于我这种小博客来说，用不着太过复杂的技术，静态网页就足够了。所以我选择了GithubPage来托管网站，因为我使用python，所以我使用了基于python的pelican作为静态网页生成器。看的有点晕？没关系，接着走下去，我会解释清楚的。</p>
<h2 id="GithubPage">GithubPage</h2><p>如果你对编程有所了解，就一定听说过<a href="https://github.com/" target="_blank" rel="external">github</a>。它号称程序员的Facebook。有着极高的人气，许多重要的项目都托管在上面。<br>简单说，它是一个具有版本管理功能的代码仓库，你可以将你的项目代码存放到github的服务器上，就像网盘一样，你可以在github上管理的的项目代码，也可以和别人一起共同协做开发。github对于程序员来说是个非常重要的网站。<br>对于一个想参与到一个项目的新手来说，看到一大堆源码，只会让人头晕脑涨，不知何处入手。他希望看到的是，一个简明易懂的网页，说明这个项目的具体情况。或者对于一个想使用github上项目软件的人来说，他需要一个向使用说明书一样的东西，来告诉他这个软件怎么使用，如何配置。因此，github就设计了Pages功能，允许用户自定义项目首页，用来替代默认的源码列表。上面有关于项目的wiki等信息，方便用户使用或参与到项目中来。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。<br>GithubPage也允许托管个人主页，所以我们将我们的博客当做一个项目托管在github上，当我们访问GithubPage时，github服务器就会根据我们博客项目中的文件生成网页文件，发送给我们。我们只要修改项目中的文件，就能够管理我们的博客。<br>使用GithubPage的好处还有：</p>
<ul>
<li>免费，无限流量，300M的存储空间对于中小型博客来说够用了</li>
<li>管理发布简单方便，你只需要关注与内容，其他的都有github帮你搞定</li>
<li>享受git的版本管理功能，不用担心文章遗失。</li>
</ul>
<h3 id="git入门">git入门</h3><p>当然，github是需要有一定的使用git基础的，不过如果只是为了写博客的话，不要求完全掌握git，只需要知道git是干什么的和最基本的命令的使用即可。这方面推荐先看一看git的入门教程，goole一下git + 入门就有很多了。对于懒人来说下面为你准备了几个教程，跟着教程走，将git安装上，走一遍流程就行了<br><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简明指南</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">git教程——廖雪峰的官方网站</a><br><a href="http://backlogtool.com/git-guide/cn/intro/intro1_1.html" target="_blank" rel="external">猴子都能懂的GIT入门</a></p>
<h3 id="github帐号">github帐号</h3><p>要使用GithubPage先要有github帐号，赶紧<a href="https://github.com/" target="_blank" rel="external">去注册</a>一个吧<br>注册之后再把GitHub Bootcmap过一遍，熟悉一下流程<br><img src="http://7vzu7p.com1.z0.glb.clouddn.com/github_bootscamp.png" alt="alt tag"></p>
<h3 id="建立GitHubPage">建立GitHubPage</h3><p>这里再次偷个懒，如何建立GithubPage<a href="https://pages.github.com/" target="_blank" rel="external">官方主页</a>上已经写的很清楚了，跟着做就可以了。<br>完成github官方的教程后你访问你的 username.github.io应该就有一个 “hello world”的页面了，除此之外什么也没有。下面我们就要使用pelican生产自己博客的html文件，放上GithubPage上去。<br>ps：你可以绑定自己的域名到GithubPage上，不过首先你需要先购买一个域名，如何购买域名，绑定域名这又是另外一个故事了，网上有这方面的教程，善用google就出来了。这里也不做展开了。</p>
<h2 id="Pelican">Pelican</h2><p>建立好GithubPage之后我们看到只有一个index.html的页面，我们必须事先做好我们博客的html文件再放上GithubPage上别人才能访问的到。写html十分的复杂，这样机械的任务当然是要交给机器来做，人就只是关注与内容如何写就好了。所以我们需要一个程序来将我们的文章转化为我们博客的html文件的程序。Pelican就是这样的一个静态网页生成程序。项目中文指南<a href="https://pelican-docs-chs.readthedocs.org/en/latest/" target="_blank" rel="external">在此</a>，可以去看看简介。当然你也可以使用其他的静态网页生成程序，如基于ruby的 Jekyll，其使用都是大同小异的。<br>Pelican是基于python的程序，所以首先需要安装python。如何安装python？还是找老朋友谷歌和度娘吧。其实最好的教程还是推荐官方网站 <a href="https://www.python.org/" target="_blank" rel="external">python.org</a>。<br>安装好python之后我们还需要安装pip来安装Pelican（绕晕了，有完没完啊！————革命尚未成功，同志仍需努力，小伙伴们撑住啊！）pip是一个python包的管理程序，有了它就可以很方便的下载管理python的软件包，是使用python的必备工具。不同平台有不同的安装方法，具体怎么做？还是问问老朋友吧 ╮(╯_╰)╭  （摊手～～）</p>
<h3 id="下载安装">下载安装</h3><p>很简单，在终端或cmd下一个命令就可以了</p>
<pre><code>pip <span class="keyword">install</span> pelican
</code></pre><h3 id="建一个博客">建一个博客</h3><p>先建一个文件夹，再cd进文件夹里面，运行下面的命令，回答一串问题就可以了</p>
<pre><code><span class="built_in">mkdir</span> /<span class="built_in">path</span>/to/your/blog  
<span class="built_in">cd</span> /<span class="built_in">path</span>/to/your/blog  
pelican-quickstart
</code></pre><p>之后你就会看到文件夹里有一些的东东，这些文件具体的是：</p>
<pre><code>blog/
├── content              <span class="preprocessor">#你写的文章放在这里  </span>
│   └── (pages)  
├── output               <span class="preprocessor">#这里放生成的html文件   </span>
├── develop_server.sh    <span class="preprocessor">#一个程序用于开启本地测试服务器  </span>
├── Makefile  
├── pelicanconf.py       <span class="preprocessor"># 关于博客的配置文件  </span>
└── publishconf.py       <span class="preprocessor"># 关于发布的配置文件  </span>
</code></pre><h3 id="写文章">写文章</h3><p>现在走一遍发布博客的流程</p>
<p>这里我们使用markdown来撰写博文，markdown是一门轻量级的标记语言，用markdown来写作是一件十分惬意的事情。markdown的语法非常简单，一下子就可以掌握，推荐先google看一看一些教程吧。<a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="external">献给写作者的 Markdown 新手指南</a><br>要使用markdown之前，需要先安装markdown支持，也是一句话</p>
<pre><code>pip <span class="keyword">install</span> markdown
</code></pre><p>现在先来写一篇测试文章，放在content下，保存为test.md。pelican会自动解析.md文件作为博文的</p>
<pre><code>This <span class="keyword">is</span> a test <span class="keyword">of</span> <span class="keyword">my</span>  blog post.itle: My Test Article  
Date: <span class="number">2015</span>-<span class="number">2</span>-<span class="number">28</span>  
Category: Python  
Tags: pelican, publishing  
Slug: <span class="keyword">my</span>-<span class="keyword">first</span>-post  
Author:Your Name  
Summary: Short <span class="property">version</span> <span class="keyword">for</span> index <span class="keyword">and</span> feeds   
This <span class="keyword">is</span> a test <span class="keyword">of</span> <span class="keyword">my</span>  blog post.  
~       
</code></pre><p>前面的部分是关于这篇文章的些信息，具体情况参阅<a href="https://pelican-docs-chs.readthedocs.org/en/latest/getting_started.html#id7" target="_blank" rel="external">官方指南</a></p>
<p>写完之后cd回上一级目录，也就是blog目录中，用make生成html文件，window下没有make的请先按照make</p>
<pre><code><span class="keyword">cd</span> ..  
<span class="keyword">make</span> html
</code></pre><p>没有make的同学可以直接在主目录下用pelican就可以了</p>
<pre><code>pelican
</code></pre><p>之后就可以在output文件夹里找到一堆东东，这就是你的博客文件。在blog目录下，可以运行</p>
<pre><code><span class="built_in">make</span> serve
</code></pre><p>没有make的同学可以直接用主目录下的develop_server.sh,具体用法如下：</p>
<pre><code>./<span class="tag">develop_server</span><span class="class">.sh</span> (stop) (start) (restart) <span class="attr_selector">[port]</span>
</code></pre><p>启动一个本地的测试服务器，现在在浏览器地址栏中输入127.0.0.1:8000跳转就可以预览你的博客。</p>
<h3 id="发布">发布</h3><p>现在博客文件已经准备好，要将它们发布到github上去。先初始化git，添加你的GithubPage远程仓库，commit所有文件，在push上去即可</p>
<pre><code><span class="keyword">cd</span> output      #切换到output文件夹下  
git init  
git <span class="built_in">add</span> --<span class="keyword">all</span>  
git remote <span class="built_in">add</span> origin http<span class="variable">s:</span>//github.<span class="keyword">com</span>/username.github.io.git  
git pull origin master  
git commit -<span class="keyword">am</span> <span class="string">'commit'</span>  
git push  origin master
</code></pre><p>现在访问 username.github.io 就可以看到你的博客已经放到网上去了。<br>以后更新了文章也是一样先make html，再commit，最后push上github就可以了</p>
<p>更多博客的使用和配置请期待下一篇。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2015/02/28/setup-blog/" data-id="cijleyexg0003qi1z0vgagizy" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2015/02/28/setup-blog/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">STep by STep</a>
      &copy; 2016 Sine Yuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'sineyuansblog';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>