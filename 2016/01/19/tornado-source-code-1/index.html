<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>tornado源码分析笔记(1) | STep by STep</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Tornado 是一个用 Python 实现的 Web 服务器框架，其最大的特点是使用异步非阻塞IO的处理方式来获取高负载和高性能。到底 Tornado 的底层是如何实现的呢？我们来一起看看。
注明一下，这里展示的 Tornado 版本为4.2.1，不同版本可能会有一些出入。
让我们从官方的 helloworld 开始我们的旅程：
helloworld.py:
import tornado.htt">
<meta property="og:type" content="article">
<meta property="og:title" content="tornado源码分析笔记(1)">
<meta property="og:url" content="http://sineyuan.github.io/2016/01/19/tornado-source-code-1/index.html">
<meta property="og:site_name" content="STep by STep">
<meta property="og:description" content="Tornado 是一个用 Python 实现的 Web 服务器框架，其最大的特点是使用异步非阻塞IO的处理方式来获取高负载和高性能。到底 Tornado 的底层是如何实现的呢？我们来一起看看。
注明一下，这里展示的 Tornado 版本为4.2.1，不同版本可能会有一些出入。
让我们从官方的 helloworld 开始我们的旅程：
helloworld.py:
import tornado.htt">
<meta property="og:updated_time" content="2016-01-25T02:45:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tornado源码分析笔记(1)">
<meta name="twitter:description" content="Tornado 是一个用 Python 实现的 Web 服务器框架，其最大的特点是使用异步非阻塞IO的处理方式来获取高负载和高性能。到底 Tornado 的底层是如何实现的呢？我们来一起看看。
注明一下，这里展示的 Tornado 版本为4.2.1，不同版本可能会有一些出入。
让我们从官方的 helloworld 开始我们的旅程：
helloworld.py:
import tornado.htt">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">STep by STep</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/SineYuan" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/14/clickhouse-kafka/">从kafka导入数据到Clickhouse</a>
          </li>
        
          <li>
            <a href="/2017/12/29/clickhouse-docker-quick-start/">用Docker快速上手Clickhouse</a>
          </li>
        
          <li>
            <a href="/2017/03/16/mxnet-begin/">MXNet上手</a>
          </li>
        
          <li>
            <a href="/2017/03/02/tensorflow-mnist-pratice/">Tensorflow Mnist手写数字识别Go实战</a>
          </li>
        
          <li>
            <a href="/2017/02/19/tensorflow-windows-installation/">在Windows上安装Tensorflow</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main"><article id="post-tornado-source-code-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/19/tornado-source-code-1/" class="article-date">
  <time datetime="2016-01-19T12:11:34.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      tornado源码分析笔记(1)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tornado 是一个用 Python 实现的 Web 服务器框架，其最大的特点是使用异步非阻塞IO的处理方式来获取高负载和高性能。到底 Tornado 的底层是如何实现的呢？我们来一起看看。</p>
<p>注明一下，这里展示的 Tornado 版本为4.2.1，不同版本可能会有一些出入。</p>
<p>让我们从官方的 helloworld 开始我们的旅程：</p>
<p>helloworld.py:</p>
<pre><code>import tornado<span class="class">.httpserver</span>
import tornado<span class="class">.ioloop</span>
import tornado<span class="class">.options</span>
import tornado<span class="class">.web</span>

from tornado<span class="class">.options</span> import define, options

<span class="function"><span class="title">define</span><span class="params">(<span class="string">"port"</span>, default=<span class="number">8888</span>, help=<span class="string">"run on the given port"</span>, type=int)</span></span>


class <span class="function"><span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span></span>:
    def <span class="function"><span class="title">get</span><span class="params">(self)</span></span>:
        self.<span class="function"><span class="title">write</span><span class="params">(<span class="string">"Hello, world"</span>)</span></span>


def <span class="function"><span class="title">main</span><span class="params">()</span></span>:
    tornado<span class="class">.options</span><span class="class">.parse_command_line</span>()
    application = tornado<span class="class">.web</span><span class="class">.Application</span>([
        (r<span class="string">"/"</span>, MainHandler),
    ])
    http_server = tornado<span class="class">.httpserver</span><span class="class">.HTTPServer</span>(application)
    http_server.<span class="function"><span class="title">listen</span><span class="params">(options.port)</span></span>
    tornado<span class="class">.ioloop</span><span class="class">.IOLoop</span><span class="class">.current</span>().<span class="function"><span class="title">start</span><span class="params">()</span></span>


<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="function"><span class="title">main</span><span class="params">()</span></span>                         
</code></pre><p>Tornado 的基本框架是先实现处理各种模式的<code>RequestHandler</code>类，用这些模式和对应的 Handler 初始化一个<code>Application</code>类，再用这个<code>Application</code>类初始化一个<code>HTTPServer</code>，设置监听端口，再启动<code>IOLoop</code> 。<br>我们先来看<code>Application</code>:</p>
<p>web.py:</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Application</span><span class="params">(httputil.HTTPServerConnectionDelegate)</span>:</span>

    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, handlers=None, default_host=<span class="string">""</span>, transforms=None,
                 **settings)</span>:</span>

        ...  <span class="comment"># 省略transform和ui模块的设置</span>

        self.handlers = []
        self.named_handlers = {}
        self.default_host = default_host
        self.settings = settings
        <span class="keyword">if</span> self.settings.get(<span class="string">"static_path"</span>):
            path = self.settings[<span class="string">"static_path"</span>]
            handlers = list(handlers <span class="keyword">or</span> [])
            static_url_prefix = settings.get(<span class="string">"static_url_prefix"</span>,
                                             <span class="string">"/static/"</span>)
            static_handler_class = settings.get(<span class="string">"static_handler_class"</span>,
                                                StaticFileHandler)
            static_handler_args = settings.get(<span class="string">"static_handler_args"</span>, {})
            static_handler_args[<span class="string">'path'</span>] = path
            <span class="keyword">for</span> pattern <span class="keyword">in</span> [re.escape(static_url_prefix) + <span class="string">r"(.*)"</span>,
                            <span class="string">r"/(favicon\.ico)"</span>, <span class="string">r"/(robots\.txt)"</span>]:
                handlers.insert(<span class="number">0</span>, (pattern, static_handler_class,
                                    static_handler_args))
        <span class="keyword">if</span> handlers:
            self.add_handlers(<span class="string">".*$"</span>, handlers)

        ...
</code></pre><p><code>Application</code>的初始化的工作主要是设置 transform , 加载 ui 模块，为静态文件设置<code>StaticFileHandler</code>，后面还有为 debug 模式设置 autoreload，最主要的还是调用<code>self.add_handlers(&quot;.*$&quot;, handlers)</code>来添加 handlers，</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_handlers</span><span class="params">(self, host_pattern, host_handlers)</span>:</span>
    <span class="string">"""Appends the given handlers to our handler list."""</span>
    <span class="keyword">if</span> <span class="keyword">not</span> host_pattern.endswith(<span class="string">"$"</span>):
        host_pattern += <span class="string">"$"</span>
    handlers = []

    <span class="comment"># 确保全部匹配的 handler 处于 self.handlers 的最后 </span>
    <span class="keyword">if</span> self.handlers <span class="keyword">and</span> self.handlers[-<span class="number">1</span>][<span class="number">0</span>].pattern == <span class="string">'.*$'</span>:
        self.handlers.insert(-<span class="number">1</span>, (re.compile(host_pattern), handlers))
    <span class="keyword">else</span>:
        self.handlers.append((re.compile(host_pattern), handlers))

    <span class="keyword">for</span> spec <span class="keyword">in</span> host_handlers:
        <span class="keyword">if</span> isinstance(spec, (tuple, list)):
            <span class="keyword">assert</span> len(spec) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)
            spec = URLSpec(*spec)
        handlers.append(spec)
        <span class="keyword">if</span> spec.name:
            <span class="keyword">if</span> spec.name <span class="keyword">in</span> self.named_handlers:
                app_log.warning(
                    <span class="string">"Multiple handlers named %s; replacing previous value"</span>,
                    spec.name)
            self.named_handlers[spec.name] = spec
</code></pre><p>接下来我们看<code>HttpServer</code>类，它的初始化没什么好讲的，值得注意到一点是它以<code>self.request_callback</code>属性来保存<code>Application</code>类。直接来看<code>listen</code>方法<code>HttpServer</code>的 listen 方法直接继承自<code>TCPServer</code>的<code>listen</code>方法。</p>
<p>tcpserver.py:</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">listen</span><span class="params">(self, port, address=<span class="string">""</span>)</span>:</span>

        sockets = bind_sockets(port, address=address)
        self.add_sockets(sockets)
</code></pre><p>Socket 连接要经过 create -&gt; bind -&gt; listen 的三部曲。bind_sockets 函数走完了前面两步：就是创建 socket 并进行设置，然后 bind。因为输入的 address 可能对应多个IP地址，所以<code>bind_sockets</code>返回值为一个 socket 的列表。 我们来看<code>add_sockets</code>：</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_sockets</span><span class="params">(self, sockets)</span>:</span>

        <span class="keyword">if</span> self.io_loop <span class="keyword">is</span> <span class="keyword">None</span>:
            self.io_loop = IOLoop.current()

        <span class="keyword">for</span> sock <span class="keyword">in</span> sockets:
            self._sockets[sock.fileno()] = sock
            add_accept_handler(sock, self._handle_connection,
                               io_loop=self.io_loop)
</code></pre><p>一开始先获得<code>IOLoop</code>实例，对于<code>IOLoop</code>是全局的单例，关于<code>IOLoop</code>的将在其他地方详述。然后调用<code>add_accept_handler</code>用于设置 socket 接收到连接时的回调函数为<code>TCPServer._handle_connection</code>。先来看 <code>add_accept_handler</code>。</p>
<p>netutil.py:</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">add_accept_handler</span><span class="params">(sock, callback, io_loop=None)</span>:</span>

    <span class="keyword">if</span> io_loop <span class="keyword">is</span> <span class="keyword">None</span>:
        io_loop = IOLoop.current()

    <span class="function"><span class="keyword">def</span> <span class="title">accept_handler</span><span class="params">(fd, events)</span>:</span>

        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(_DEFAULT_BACKLOG):
            <span class="keyword">try</span>:
                connection, address = sock.accept()
            <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:
                <span class="comment"># _ERRNO_WOULDBLOCK indicate we have accepted every</span>
                <span class="comment"># connection that is available.</span>
                <span class="keyword">if</span> errno_from_exception(e) <span class="keyword">in</span> _ERRNO_WOULDBLOCK:
                    <span class="keyword">return</span>
                <span class="comment"># ECONNABORTED indicates that there was a connection</span>
                <span class="comment"># but it was closed while still in the accept queue.</span>
                <span class="comment"># (observed on FreeBSD).</span>
                <span class="keyword">if</span> errno_from_exception(e) == errno.ECONNABORTED:
                    <span class="keyword">continue</span>
                <span class="keyword">raise</span>
            callback(connection, address)
    io_loop.add_handler(sock, accept_handler, IOLoop.READ)
</code></pre><p><code>add_accept_handler</code>向<code>io_loop</code>注册了 socket，在<code>IOLoop.READ</code>事件到来时的 调用<code>accept_handler</code>来处理 socket 事件。<code>accept_handler</code>就定义在<code>add_accept_handler</code>内部，可以看到其实就是<code>sock.accept()</code>获取连接的 socket 和 address，然后再调用回调函数，也就是<code>TCPServer. _handle_connection</code>:</p>
<p>tcpserver.py:</p>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">_handle_connection</span><span class="params">(self, connection, address)</span>:</span>
        <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:

            ...  <span class="comment"># 处理ssl</span>

        <span class="keyword">try</span>:
            <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                stream = SSLIOStream(connection, io_loop=self.io_loop,
                                     max_buffer_size=self.max_buffer_size,
                                     read_chunk_size=self.read_chunk_size)
            <span class="keyword">else</span>:
                stream = IOStream(connection, io_loop=self.io_loop,
                                  max_buffer_size=self.max_buffer_size,
                                  read_chunk_size=self.read_chunk_size)
            future = self.handle_stream(stream, address)
            <span class="keyword">if</span> future <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
                self.io_loop.add_future(future, <span class="keyword">lambda</span> f: f.result())
        <span class="keyword">except</span> Exception:
            app_log.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="keyword">True</span>)
</code></pre><p>我们略去处理 ssl 的部分，在这里主要的内容就是将 socket 封装成<code>IOStream</code>类给上层处理。<code>handle_stream</code>方法在<code>HttpServer</code>中实现，返回<code>None</code>或一个<code>future</code>对象。关于<code>future</code>对象后面再细讲。</p>
<p>到此<code>Application</code>和<code>httpserver</code>就准备就绪，下面我们来看看 tornado 的核心——<code>IOLoop</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/19/tornado-source-code-1/" data-id="cjdcpz05t0003cm13lu42fruj" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/19/tornado-source-code-1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/01/19/tornado-source-code-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          tornado源码分析笔记(2)
        
      </div>
    </a>
  
  
    <a href="/2016/01/06/python-captcha/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">使用Python做验证码识别</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">STep by STep</a>
      &copy; 2018 Sine Yuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'sineyuansblog';
  
  var disqus_url = 'http://sineyuan.github.io/2016/01/19/tornado-source-code-1/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>