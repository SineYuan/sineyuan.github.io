<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>tornado源码分析笔记(3) | STep by STep</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="今天我们来讲讲tornado的Future和coroutine。
Future首先什么是future？按照我的理解，Future是一个用来保存异步处理的结果和回调的一个类。tornado的Future其实是实现了跟python concurrent这个包一样的api。在concurrent这个包里面是这样用Future的
12345678910import concurrent.futuresde">
<meta property="og:type" content="article">
<meta property="og:title" content="tornado源码分析笔记(3)">
<meta property="og:url" content="http://sineyuan.github.io/2016/01/25/tornado-source-code-3/index.html">
<meta property="og:site_name" content="STep by STep">
<meta property="og:description" content="今天我们来讲讲tornado的Future和coroutine。
Future首先什么是future？按照我的理解，Future是一个用来保存异步处理的结果和回调的一个类。tornado的Future其实是实现了跟python concurrent这个包一样的api。在concurrent这个包里面是这样用Future的
12345678910import concurrent.futuresde">
<meta property="og:updated_time" content="2016-01-26T06:08:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="tornado源码分析笔记(3)">
<meta name="twitter:description" content="今天我们来讲讲tornado的Future和coroutine。
Future首先什么是future？按照我的理解，Future是一个用来保存异步处理的结果和回调的一个类。tornado的Future其实是实现了跟python concurrent这个包一样的api。在concurrent这个包里面是这样用Future的
12345678910import concurrent.futuresde">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">STep by STep</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/SineYuan" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/28/go-error-handle/">Golang错误处理</a>
          </li>
        
          <li>
            <a href="/2016/05/29/deploy-k8s-on-coreos/">CoreOS部署kubernetes</a>
          </li>
        
          <li>
            <a href="/2016/05/29/coreos-osx-without-vagrant/">OSX上摆脱vagrant搭建CoreOS集群</a>
          </li>
        
          <li>
            <a href="/2016/01/25/tornado-source-code-3/">tornado源码分析笔记(3)</a>
          </li>
        
          <li>
            <a href="/2016/01/19/tornado-source-code-2/">tornado源码分析笔记(2)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main"><article id="post-tornado-source-code-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/25/tornado-source-code-3/" class="article-date">
  <time datetime="2016-01-24T16:19:32.000Z" itemprop="datePublished">2016-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      tornado源码分析笔记(3)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天我们来讲讲tornado的<code>Future</code>和coroutine。</p>
<h2 id="Future">Future</h2><p>首先什么是<code>future</code>？按照我的理解，<code>Future</code>是一个用来保存异步处理的结果和回调的一个类。tornado的<code>Future</code>其实是实现了跟python <a href="https://docs.python.org/3/library/concurrent.futures.html" target="_blank" rel="external">concurrent</a>这个包一样的api。在<code>concurrent</code>这个包里面是这样用<code>Future</code>的</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import concurrent<span class="class">.futures</span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">done_callback</span><span class="params">(future)</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">"I am done"</span>)</span></span></span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(future.result()</span></span>)</span><br><span class="line"></span><br><span class="line">with concurrent<span class="class">.futures</span><span class="class">.ThreadPoolExecutor</span>(max_workers=<span class="number">1</span>) as executor:</span><br><span class="line">    future = executor.<span class="function"><span class="title">submit</span><span class="params">(pow, <span class="number">323</span>, <span class="number">1235</span>)</span></span></span><br><span class="line">    future.<span class="function"><span class="title">add_done_callback</span><span class="params">(done_callback)</span></span></span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(future.done()</span></span>)</span><br></pre></td></tr></table></figure>
<p><code>ThreadPoolExecutor</code>在线程池中执行<code>pow</code>，不等函数执行完就立即返回一个<code>future</code>作为一个桥梁，拿到这个<code>future</code>后程序就可以去做其他事情了，当<code>pow</code>执行完之后回调用<code>done_callback</code>。而主线程也可以通过<code>future</code>来获取运行情况或者进行取消等操作。</p>
<p><code>Future</code>的源码在concurrent.py里面，很简单，这里也就不贴出来了。在tornado中，<code>Future</code>的使用是通过<code>IOLoop</code>的<code>add_future</code>方法起作用的。</p>
<p>ioloop.py:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_future</span><span class="params">(self, future, callback)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> is_future(future)</span><br><span class="line">    callback = stack_context.wrap(callback)</span><br><span class="line">    future.add_done_callback(</span><br><span class="line">        <span class="keyword">lambda</span> future: self.add_callback(callback, future))</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>add_future</code>为<code>future</code>添加了一个回调函数，当<code>future</code>完成的时候，也就是调用了<code>future.set_result</code>或<code>future.set_exception</code>后向<code>IOLoop</code>注册了<code>callback</code>函数，当<code>IOLoop</code>下一轮poll之前就会调用这个<code>callback</code>函数。下面是一个简单的使用例子，耗时任务使用另外的线程完成。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import <span class="tag">time</span></span><br><span class="line">import threading</span><br><span class="line">import tornado<span class="class">.ioloop</span></span><br><span class="line">from tornado<span class="class">.concurrent</span> import Future</span><br><span class="line"></span><br><span class="line">ioloop = tornado<span class="class">.ioloop</span><span class="class">.IOLoop</span><span class="class">.current</span>()</span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">long_task</span><span class="params">(future, sec=<span class="number">5</span>)</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(<span class="string">"long task start"</span>)</span></span></span><br><span class="line">    <span class="tag">time</span>.<span class="function"><span class="title">sleep</span><span class="params">(sec)</span></span></span><br><span class="line">    future.<span class="function"><span class="title">set_result</span><span class="params">(<span class="string">"long task done in %s sec"</span> % sec)</span></span></span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">after_task_done</span><span class="params">(future)</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span><span class="params">(future.result()</span></span>)</span><br><span class="line"></span><br><span class="line">def <span class="function"><span class="title">test_future</span><span class="params">()</span></span>:</span><br><span class="line">    future = <span class="function"><span class="title">Future</span><span class="params">()</span></span></span><br><span class="line">    threading.<span class="function"><span class="title">Thread</span><span class="params">(target=long_task, args=(future,)</span></span>).<span class="function"><span class="title">start</span><span class="params">()</span></span></span><br><span class="line">    ioloop.<span class="function"><span class="title">add_future</span><span class="params">(future, after_task_done)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    ioloop.<span class="function"><span class="title">add_callback</span><span class="params">(test_future)</span></span></span><br><span class="line">    ioloop.<span class="function"><span class="title">start</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h2 id="coroutine">coroutine</h2><p>异步的事件驱动最令人诟病的一点就是不停的回调回调，给写程序的时候带来很大的困难。针对这个痛点，tornado利用了基于python的生成器的协程来实现用同步的方式写异步的代码的。就让我们来看一看其背后的黑魔法吧。</p>
<p>先从demo开始：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class <span class="function"><span class="title">GenAsyncHandler</span><span class="params">(RequestHandler)</span></span>:</span><br><span class="line">    @gen<span class="class">.coroutine</span></span><br><span class="line">    def <span class="function"><span class="title">get</span><span class="params">(self)</span></span>:</span><br><span class="line">        http_client = <span class="function"><span class="title">AsyncHTTPClient</span><span class="params">()</span></span></span><br><span class="line">        response = yield http_client.<span class="function"><span class="title">fetch</span><span class="params">(<span class="string">"http://example.com"</span>)</span></span></span><br><span class="line">        <span class="function"><span class="title">do_something_with_response</span><span class="params">(response)</span></span></span><br><span class="line">        self.<span class="function"><span class="title">render</span><span class="params">(<span class="string">"template.html"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><code>get</code>方法在<code>gen.coroutine</code>装饰器的下在执行异步方法时yield就可以可以将控制权还给IOLoop，当异步方法回获得结果时返回<code>get</code>方法，将结果赋值给<code>response</code>后继续执行。我们知道在一个函数中有yield的话这个函数的返回值就变成了一个生成器，当异步函数的结果到来时，必定会调用生成器的<code>send</code>方法将结果传入里面。我们先来看<code>gen.coroutine</code>。</p>
<p>gen.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(func, replace_callback=True)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _make_coroutine_wrapper(func, replace_callback=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>很简单，返回一个<code>_make_coroutine_wrapper</code>包装的函数。来看<code>_make_coroutine_wrapper</code>：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">def _make_coroutine_wrapper(func, replace_callback):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        future = <span class="type">TracebackFuture</span>()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 有callback关键词的话为callback添加一个future，future完成时执行</span></span><br><span class="line">        <span class="keyword">if</span> replace_callback <span class="keyword">and</span> 'callback' <span class="keyword">in</span> kwargs:</span><br><span class="line">            callback = kwargs.pop('callback')</span><br><span class="line">            <span class="type">IOLoop</span>.current().add_future(</span><br><span class="line">                future, lambda future: callback(future.<span class="literal">result</span>()))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用func，根据结果的不同进行不同的处理</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="literal">result</span> = func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> (<span class="type">Return</span>, <span class="type">StopIteration</span>) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="literal">result</span> = getattr(e, 'value', <span class="type">None</span>)</span><br><span class="line">        <span class="keyword">except</span> <span class="type">Exception</span>:</span><br><span class="line">            future.set_exc_info(sys.exc_info())</span><br><span class="line">            <span class="keyword">return</span> future</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(<span class="literal">result</span>, types.<span class="type">GeneratorType</span>):</span><br><span class="line">                <span class="comment"># Inline the first iteration of Runner.run.  This lets us</span></span><br><span class="line">                <span class="comment"># avoid the cost of creating a Runner when the coroutine</span></span><br><span class="line">                <span class="comment"># never actually yields, which in turn allows us to</span></span><br><span class="line">                <span class="comment"># use "optional" coroutines in critical path code without</span></span><br><span class="line">                <span class="comment"># performance penalty for the synchronous case.</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    orig_stack_contexts = stack_context._state.contexts</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 若result是一个生成器，则会调用一次next，在根据结果进行不同处理</span></span><br><span class="line">                    yielded = next(<span class="literal">result</span>)</span><br><span class="line">                    <span class="keyword">if</span> stack_context._state.contexts <span class="keyword">is</span> <span class="keyword">not</span> orig_stack_contexts:</span><br><span class="line">                        yielded = <span class="type">TracebackFuture</span>()</span><br><span class="line">                        yielded.set_exception(</span><br><span class="line">                            stack_context.<span class="type">StackContextInconsistentError</span>(</span><br><span class="line">                                'stack_context inconsistency (probably caused '</span><br><span class="line">                                'by <span class="keyword">yield</span> within a <span class="string">"with StackContext"</span> <span class="keyword">block</span>)'))</span><br><span class="line">                <span class="keyword">except</span> (<span class="type">StopIteration</span>, <span class="type">Return</span>) <span class="keyword">as</span> e:</span><br><span class="line">                    future.set_result(getattr(e, 'value', <span class="type">None</span>))</span><br><span class="line">                <span class="keyword">except</span> <span class="type">Exception</span>:</span><br><span class="line">                    future.set_exc_info(sys.exc_info())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="type">Runner</span>(<span class="literal">result</span>, future, yielded)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> future</span><br><span class="line">                <span class="keyword">finally</span>:</span><br><span class="line">                    <span class="comment"># Subtle memory optimization: if next() raised an exception,</span></span><br><span class="line">                    <span class="comment"># the future's exc_info contains a traceback which</span></span><br><span class="line">                    <span class="comment"># includes this stack frame.  This creates a cycle,</span></span><br><span class="line">                    <span class="comment"># which will be collected at the next full GC but has</span></span><br><span class="line">                    <span class="comment"># been shown to greatly increase memory usage of</span></span><br><span class="line">                    <span class="comment"># benchmarks (relative to the refcount-based scheme</span></span><br><span class="line">                    <span class="comment"># used in the absence of cycles).  We can avoid the</span></span><br><span class="line">                    <span class="comment"># cycle by clearing the local variable after we return it.</span></span><br><span class="line">                    future = <span class="type">None</span></span><br><span class="line">        future.set_result(<span class="literal">result</span>)</span><br><span class="line">        <span class="keyword">return</span> future</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>被<code>gen.coroutine</code>装饰的函数返回结果都会变成一个<code>Future</code>,若<code>func</code>不是一个生成器，则将结果或异常放入<code>future</code>中返回。若<code>func</code>返回一个生成器，调用<code>next</code>一次，如果还有后续，则交给<code>Runner</code>这个类来执行。结合demo上的来看，此时的<code>yielded</code>是<code>http_client.fetch(&quot;http://example.com&quot;)</code>执行都结果，必须是一个<code>Future</code>(或者<code>YieldPoint</code>，早期版本使用的，后来由<code>Future</code>代替，保留只为了兼容旧版本，这里不再讨论)，后面我们可以看到。</p>
<p>来看<code>Runner</code>类， 也在gen.py里面，在<code>Runner</code>里面最关键的是<code>run</code>和<code>handle_yield</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runner</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, gen, result_future, first_yielded)</span>:</span></span><br><span class="line">        self.gen = gen</span><br><span class="line">        self.result_future = result_future</span><br><span class="line">        self.future = _null_future</span><br><span class="line">        self.yield_point = <span class="keyword">None</span></span><br><span class="line">        self.pending_callbacks = <span class="keyword">None</span></span><br><span class="line">        self.results = <span class="keyword">None</span></span><br><span class="line">        self.running = <span class="keyword">False</span></span><br><span class="line">        self.finished = <span class="keyword">False</span></span><br><span class="line">        self.had_exception = <span class="keyword">False</span></span><br><span class="line">        self.io_loop = IOLoop.current()</span><br><span class="line"></span><br><span class="line">        self.stack_context_deactivate = <span class="keyword">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 若first_yielded的future以完成，则最少会run一次</span></span><br><span class="line">        <span class="keyword">if</span> self.handle_yield(first_yielded):</span><br><span class="line">            self.run()</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># ...省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_yield</span><span class="params">(self, yielded)</span>:</span></span><br><span class="line">        <span class="comment"># Lists containing YieldPoints require stack contexts;</span></span><br><span class="line">        <span class="comment"># other lists are handled via multi_future in convert_yielded.</span></span><br><span class="line">        <span class="keyword">if</span> (isinstance(yielded, list) <span class="keyword">and</span></span><br><span class="line">                any(isinstance(f, YieldPoint) <span class="keyword">for</span> f <span class="keyword">in</span> yielded)):</span><br><span class="line">            yielded = Multi(yielded)</span><br><span class="line">        <span class="keyword">elif</span> (isinstance(yielded, dict) <span class="keyword">and</span></span><br><span class="line">              any(isinstance(f, YieldPoint) <span class="keyword">for</span> f <span class="keyword">in</span> yielded.values())):</span><br><span class="line">            yielded = Multi(yielded)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理旧版本的YieldPoints的兼容，可以忽略...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># future未完成则向ioloop注册这个future，当future完成时调用run继续执行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.future.done() <span class="keyword">or</span> self.future <span class="keyword">is</span> moment:</span><br><span class="line">            self.io_loop.add_future(</span><br><span class="line">                self.future, <span class="keyword">lambda</span> f: self.run())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Starts or resumes the generator, running until it reaches a</span><br><span class="line">        yield point that is not ready.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.running <span class="keyword">or</span> self.finished:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.running = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                future = self.future</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> future.done():</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                self.future = <span class="keyword">None</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    orig_stack_contexts = stack_context._state.contexts</span><br><span class="line">                    exc_info = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        value = future.result()</span><br><span class="line">                    <span class="keyword">except</span> Exception:</span><br><span class="line">                        self.had_exception = <span class="keyword">True</span></span><br><span class="line">                        exc_info = sys.exc_info()</span><br><span class="line">					</span><br><span class="line">					<span class="comment"># 有异常则设置异常</span></span><br><span class="line">                    <span class="keyword">if</span> exc_info <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                        yielded = self.gen.throw(*exc_info)</span><br><span class="line">                        exc_info = <span class="keyword">None</span></span><br><span class="line">                   	<span class="comment"># 将结果send回去继续执行</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        yielded = self.gen.send(value)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> stack_context._state.contexts <span class="keyword">is</span> <span class="keyword">not</span> orig_stack_contexts:</span><br><span class="line">                        self.gen.throw(</span><br><span class="line">                            stack_context.StackContextInconsistentError(</span><br><span class="line">                                <span class="string">'stack_context inconsistency (probably caused '</span></span><br><span class="line">                                <span class="string">'by yield within a "with StackContext" block)'</span>))</span><br><span class="line">                <span class="keyword">except</span> (StopIteration, Return) <span class="keyword">as</span> e:</span><br><span class="line">                    self.finished = <span class="keyword">True</span></span><br><span class="line">                    self.future = _null_future</span><br><span class="line">                    <span class="keyword">if</span> self.pending_callbacks <span class="keyword">and</span> <span class="keyword">not</span> self.had_exception:</span><br><span class="line">                        <span class="comment"># If we ran cleanly without waiting on all callbacks</span></span><br><span class="line">                        <span class="comment"># raise an error (really more of a warning).  If we</span></span><br><span class="line">                        <span class="comment"># had an exception then some callbacks may have been</span></span><br><span class="line">                        <span class="comment"># orphaned, so skip the check in that case.</span></span><br><span class="line">                        <span class="keyword">raise</span> LeakedCallbackError(</span><br><span class="line">                            <span class="string">"finished without waiting for callbacks %r"</span> %</span><br><span class="line">                            self.pending_callbacks)</span><br><span class="line">                    self.result_future.set_result(getattr(e, <span class="string">'value'</span>, <span class="keyword">None</span>))</span><br><span class="line">                    self.result_future = <span class="keyword">None</span></span><br><span class="line">                    self._deactivate_stack_context()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">except</span> Exception:</span><br><span class="line">                    self.finished = <span class="keyword">True</span></span><br><span class="line">                    self.future = _null_future</span><br><span class="line">                    self.result_future.set_exc_info(sys.exc_info())</span><br><span class="line">                    self.result_future = <span class="keyword">None</span></span><br><span class="line">                    self._deactivate_stack_context()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="comment"># handle_yield检查yielded，若还未完成则继续向IOLoop注册future等待完成。</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.handle_yield(yielded):</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.running = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># .......</span></span><br></pre></td></tr></table></figure>
<p>在<code>Runner</code>中<code>handle_yield</code>帮我们向IOLoop注册了<code>future</code>,当<code>future</code>完成时也就是<code>http_client.fetch</code>的结果返回之后，IOLoop就好执行<code>Runner.run()</code>使我们从断点继续执行。在<code>Runner.run()</code>里将<code>future</code>的结果取出，发送进生成器里面继续执行。</p>
<p>当我们要实现自己的异步函数时，需要将耗时任务的执行放在主线程外的其它地方，返回一个<code>Future</code>对象，当耗时任务结束时设在<code>Future</code>的结果即可。配合<code>gen.coroutine</code>即可实现同步的控制流写异步的代码。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.options</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define, options</span><br><span class="line"></span><br><span class="line">define(<span class="string">"port"</span>, default=<span class="number">8888</span>, help=<span class="string">"run on the given port"</span>, type=int)</span><br><span class="line"></span><br><span class="line"><span class="decorator">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logic_handler</span><span class="params">(pk)</span>:</span></span><br><span class="line">    data = <span class="keyword">yield</span> get_data(pk)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在python3里可以在生成器直接return data</span></span><br><span class="line">    <span class="keyword">raise</span> gen.Return(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(pk)</span>:</span></span><br><span class="line">    future = Future()</span><br><span class="line">    threading.Thread(target=fetch_data_from_db, args=(future, pk)).start()</span><br><span class="line">    <span class="keyword">return</span> future</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_data_from_db</span><span class="params">(future, pk)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    future.set_result(&#123;<span class="string">"pk"</span>: pk, <span class="string">"data"</span>: <span class="string">"Data from No.%s's"</span> % pk&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="decorator">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, pk)</span>:</span></span><br><span class="line">        print(pk)</span><br><span class="line">        result = <span class="keyword">yield</span> loginc_handler(pk)</span><br><span class="line">        self.write(json.dumps(result))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    application = tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/(\d+)"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(application)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>不过在实际应用中还是会有些地方需要注意。如当一个函数使用<code>gen.coroutine</code>装饰过后，其上层的调用者也要相应改成couroutine，如上面例子的<code>logic_handler</code>如果还有很多层级依赖于db的数据的话，它们也要加<code>@gen.coroutine</code>或者返回<code>Future</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2016/01/25/tornado-source-code-3/" data-id="ciskhrwqf0001z413wj8971i4" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2016/01/25/tornado-source-code-3/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/29/coreos-osx-without-vagrant/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          OSX上摆脱vagrant搭建CoreOS集群
        
      </div>
    </a>
  
  
    <a href="/2016/01/19/tornado-source-code-2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">tornado源码分析笔记(2)</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">STep by STep</a>
      &copy; 2016 Sine Yuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'sineyuansblog';
  
  var disqus_url = 'http://sineyuan.github.io/2016/01/25/tornado-source-code-3/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>