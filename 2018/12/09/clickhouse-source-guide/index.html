<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Clickhouse源码导读 | STep by STep</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Clickhouse源码导读ClickHouse 是一个由俄罗斯搜索巨头Yandex开源的分布式列存储OLAP数据库。最突出的特点有特点就是一个快字。为了搞懂Clickhouse为什么快，我粗略的看了看Clickhouse的源码，总结一份导读指南，方便他人探索。
基本流程先从github下载源码看看，本文内容基于 v18.14.17-stable 版本。Clickhouse整个项目的结构还是很清晰">
<meta property="og:type" content="article">
<meta property="og:title" content="Clickhouse源码导读">
<meta property="og:url" content="http://sineyuan.github.io/2018/12/09/clickhouse-source-guide/index.html">
<meta property="og:site_name" content="STep by STep">
<meta property="og:description" content="Clickhouse源码导读ClickHouse 是一个由俄罗斯搜索巨头Yandex开源的分布式列存储OLAP数据库。最突出的特点有特点就是一个快字。为了搞懂Clickhouse为什么快，我粗略的看了看Clickhouse的源码，总结一份导读指南，方便他人探索。
基本流程先从github下载源码看看，本文内容基于 v18.14.17-stable 版本。Clickhouse整个项目的结构还是很清晰">
<meta property="og:updated_time" content="2018-12-14T11:26:03.961Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clickhouse源码导读">
<meta name="twitter:description" content="Clickhouse源码导读ClickHouse 是一个由俄罗斯搜索巨头Yandex开源的分布式列存储OLAP数据库。最突出的特点有特点就是一个快字。为了搞懂Clickhouse为什么快，我粗略的看了看Clickhouse的源码，总结一份导读指南，方便他人探索。
基本流程先从github下载源码看看，本文内容基于 v18.14.17-stable 版本。Clickhouse整个项目的结构还是很清晰">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <!-- <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <!-- <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">STep by STep</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/SineYuan" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
</header>
      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sineyuan.github.io"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/09/clickhouse-source-guide/">Clickhouse源码导读</a>
          </li>
        
          <li>
            <a href="/2018/01/14/clickhouse-kafka/">从kafka导入数据到Clickhouse</a>
          </li>
        
          <li>
            <a href="/2017/12/29/clickhouse-docker-quick-start/">用Docker快速上手Clickhouse</a>
          </li>
        
          <li>
            <a href="/2017/03/16/mxnet-begin/">MXNet上手</a>
          </li>
        
          <li>
            <a href="/2017/03/02/tensorflow-mnist-pratice/">Tensorflow Mnist手写数字识别Go实战</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main"><article id="post-clickhouse-source-guide" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/clickhouse-source-guide/" class="article-date">
  <time datetime="2018-12-08T16:00:00.000Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Clickhouse源码导读
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Clickhouse源码导读">Clickhouse源码导读</h1><p>ClickHouse 是一个由俄罗斯搜索巨头Yandex开源的分布式列存储OLAP数据库。最突出的特点有特点就是一个快字。为了搞懂Clickhouse为什么快，我粗略的看了看Clickhouse的源码，总结一份导读指南，方便他人探索。</p>
<h2 id="基本流程">基本流程</h2><p>先从<a href="https://github.com/yandex/ClickHouse" target="_blank" rel="external">github</a>下载源码看看，本文内容基于 <code>v18.14.17-stable</code> 版本。Clickhouse整个项目的结构还是很清晰的，入口的 main函数在 <code>dbms/programs/main.cpp</code>。主程序会根据指令分发到 <code>dbms/programs</code> 目录下的程序中处理。我们主要关注 <code>clickhouse server</code>，所以直接来到 <code>dbms/programs/server/Server.cpp</code>，一路走下来解析参数配置，初始化server，再启动服务监听端口。</p>
<p>clickhouse 使用的是 <a href="https://pocoproject.org/" target="_blank" rel="external"><code>poco</code></a> 这个网络库来处理网络请求，每个client连接的处理逻辑在 <code>dbms/programs/server/TCPHandler.cpp</code>的<code>TCPHandler::runImpl()</code>方法里面。除去握手，初始化上下文，异常处理和数据统计的代码，主要的业务可以抽象成:</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// dbms/programs/server/TCPHandler.cpp</span><br><span class="line"></span><br><span class="line">TCPHandler.runImpl()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    while(<span class="number">1</span>) &#123;</span><br><span class="line">        receivePacket()</span><br><span class="line"></span><br><span class="line">        /// Processing Query</span><br><span class="line">        <span class="keyword">state</span>.io = executeQuery(<span class="keyword">state</span>.query, query_context, false, <span class="keyword">state</span>.stage);</span><br><span class="line"></span><br><span class="line">        if (<span class="keyword">state</span>.io.<span class="keyword">out</span>)</span><br><span class="line">            <span class="keyword">state</span>.need_receive_data_for_insert = true;</span><br><span class="line"></span><br><span class="line">        if (<span class="keyword">state</span>.need_receive_data_for_insert)</span><br><span class="line">            processInsertQuery(global_settings);</span><br><span class="line">        else</span><br><span class="line">            processOrdinaryQuery();</span><br><span class="line"></span><br><span class="line">    ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client发送的sql在 <code>executeQuery</code> 函数处理，<code>processInsertQuery</code> 和 <code>processOrdinaryQuery</code> 负责将结果返回给client。</p>
<p><code>executeQuery</code> 函数的实现在<code>dbms/src/Interpreters/executeQuery.cpp</code>, 主要逻辑简化如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbms/src/Interpreters/executeQuery<span class="built_in">.</span>cpp </span><br><span class="line"></span><br><span class="line">executeQueryImpl(<span class="attribute">...</span>)</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="attribute">...</span></span><br><span class="line">	ast = parseQuery(parser, begin, end, <span class="string">""</span>, max_query_size);</span><br><span class="line">	<span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">	auto interpreter = InterpreterFactory<span class="tag">::get</span>(ast, context, stage);</span><br><span class="line">    res = interpreter<span class="subst">-&gt;</span>execute();</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类比 mysql 的处理流程，先解析sql语句生成抽象语法树(AST)，<code>InterpreterFactory</code>工厂类根据AST生成 执行器<code>Interpreter</code>类实例来执行。</p>
<p><code>interpreter-&gt;execute()</code> 返回到结果 <code>res</code> 是一个 <code>BlockIO</code>, <code>BlockIO</code> 其实就是一个 <code>BlockInputStream</code>和<code>BlockOutputStream</code>的一个封装。这里就引出了 Clickhouse 里面的一些重要概念。 </p>
<h2 id="Block和Block_Stream">Block和Block Stream</h2><p>Clickhouse是面向OLAP的列存储数据库系统，数据的存储和读写都是批量处理的。根据<a href="https://clickhouse.yandex/docs/zh/development/architecture/#block" target="_blank" rel="external">文档</a>, 一个<code>Block</code>代表着一批的数据，内部是用列来划分的，也就是一个<code>(IColumn, IDataType, column name)</code>三元组的集合。Clickhouse 的数据处理都是以Block为单位的，而Clickhouse的高性能也得益于能够使用向量化技术一次批量的处理一个Block里同类型的数据。 </p>
<p>而 <code>Block Stream</code>就是一个个 <code>Block</code> 组成的数据流。<code>Block Stream</code>分为两种，负责数据写入的实现 <code>IBlockOutputStream</code>接口，通过<code>write</code>方法写入一个<code>Block</code>。负责数据读取的实现 <code>IBlockInputStream</code>接口，通过<code>read</code>方法读取一个<code>Block</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/src/DataStreams/IBlockOutputStream.h</span></span><br><span class="line"><span class="keyword">class</span> IBlockOutputStream : <span class="keyword">private</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Write block.</span><br><span class="line">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> Block &amp; block)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbms/src/DataStreams/IBlockInputStream.h</span></span><br><span class="line"><span class="keyword">class</span> IBlockInputStream : <span class="keyword">private</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IBlockInputStream() &#123;&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Read next block.</span><br><span class="line">      * If there are no more blocks, return an empty block (for which operator `bool` returns false).</span><br><span class="line">      * <span class="doctag">NOTE:</span> Only one thread can read from one instance of IBlockInputStream simultaneously.</span><br><span class="line">      * This also applies for readPrefix, readSuffix.</span><br><span class="line">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Block <span class="title">read</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的Stream可以组合起来完成数据的转化。比如最初的 <code>IBlockInputStream</code>外层套一个 <code>FilterBlockInputStream</code>过滤掉不符合条件的数据，再接一个<code>AggregatingBlockInputStream</code>将原始数据聚合给下一个 <code>IBlockInputStream</code>。其实<code>Block Stream</code>类似<code>TiDB</code>里面的算子, 或者类比<code>Python</code>的迭代器，最外层不断调用 <code>read</code>/<code>write</code>方法驱动整个计算的进行。</p>
<p>下面我们追踪最简单的数据写入Insert过程和查询Select过程讲讲相关的代码。</p>
<h2 id="写入">写入</h2><p>让我们回到<code>InterpreterFactory</code>, Insert语句对应<code>InterpreterInsertQuery</code>这个执行器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/src/Interpreters/InterpreterFactory.cpp</span></span><br><span class="line"></span><br><span class="line">InterpreterFactory::get() </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (typeid_cast&lt;ASTSelectQuery *&gt;(query.get()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// This is internal part of ASTSelectWithUnionQuery.</span></span><br><span class="line">        <span class="comment">/// Even if there is SELECT without union, it is represented by ASTSelectWithUnionQuery with single ASTSelectQuery as a child.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;InterpreterSelectQuery&gt;(query, context, Names&#123;&#125;, stage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (typeid_cast&lt;ASTSelectWithUnionQuery *&gt;(query.get()))</span><br><span class="line">    &#123;</span><br><span class="line">        ProfileEvents::increment(ProfileEvents::SelectQuery);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;InterpreterSelectWithUnionQuery&gt;(query, context, Names&#123;&#125;, stage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (typeid_cast&lt;ASTInsertQuery *&gt;(query.get()))</span><br><span class="line">    &#123;</span><br><span class="line">        ProfileEvents::increment(ProfileEvents::InsertQuery);</span><br><span class="line">        <span class="comment">/// readonly is checked inside InterpreterInsertQuery</span></span><br><span class="line">        <span class="keyword">bool</span> allow_materialized = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(context.getSettingsRef().insert_allow_materialized_columns);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::make_unique&lt;InterpreterInsertQuery&gt;(query, context, allow_materialized);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ....... <span class="comment">// 分发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/src/Interpreters/InterpreterInsertQuery.cpp</span></span><br><span class="line"></span><br><span class="line">StoragePtr InterpreterInsertQuery::getTable(<span class="keyword">const</span> ASTInsertQuery &amp; <span class="keyword">query</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">query</span>.table_function)</span><br><span class="line">    &#123;</span><br><span class="line">        auto table_function = typeid_cast&lt;<span class="keyword">const</span> ASTFunction *&gt;(<span class="keyword">query</span>.table_function.<span class="literal">get</span>());</span><br><span class="line">        <span class="keyword">const</span> auto &amp; factory = TableFunctionFactory::instance();</span><br><span class="line">        <span class="keyword">return</span> factory.<span class="literal">get</span>(table_function-&gt;name, context)-&gt;execute(<span class="keyword">query</span>.table_function, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Into what table to write.</span></span><br><span class="line">    <span class="keyword">return</span> context.getTable(<span class="keyword">query</span>.database, <span class="keyword">query</span>.<span class="keyword">table</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BlockIO InterpreterInsertQuery::execute()</span><br><span class="line">&#123;</span><br><span class="line">	... </span><br><span class="line">	StoragePtr <span class="keyword">table</span> = getTable(<span class="keyword">query</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">out</span> = std::make_shared&lt;PushingToViewsBlockOutputStream&gt;(<span class="keyword">query</span>.database, <span class="keyword">query</span>.<span class="keyword">table</span>, <span class="keyword">table</span>, context, query_ptr, <span class="keyword">query</span>.no_destination);</span><br><span class="line">	...	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PushingToViewsBlockOutputStream</code>的会先写入更低层的<code>BlockOutputStream</code>, 然后查看一下写入的数据源是否有 <code>MaterialView</code>,若有，调用<code>process</code>方法用<code>MaterializingBlockInputStream</code>往相关的<code>MaterialView</code>写入数据。而<code>PushingToViewsBlockOutputStream</code>更低层的<code>BlockOutputStream</code>是 <code>getTable</code> 方法获取的<code>IStorage</code>对象提供的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/src/Storages/IStorage.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> IStorage : <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;IStorage&gt;, <span class="keyword">private</span> boost::noncopyable, <span class="keyword">public</span> ITableDeclaration</span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> BlockOutputStreamPtr <span class="title">write</span><span class="params">(</span><br><span class="line">        <span class="keyword">const</span> ASTPtr &amp; <span class="comment">/*query*/</span>,</span><br><span class="line">        <span class="keyword">const</span> Settings &amp; <span class="comment">/*settings*/</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">"Method write is not supported by storage "</span> + getName(), ErrorCodes::NOT_IMPLEMENTED);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BlockInputStreams <span class="title">read</span><span class="params">(</span><br><span class="line">        <span class="keyword">const</span> Names &amp; <span class="comment">/*column_names*/</span>,</span><br><span class="line">        <span class="keyword">const</span> SelectQueryInfo &amp; <span class="comment">/*query_info*/</span>,</span><br><span class="line">        <span class="keyword">const</span> Context &amp; <span class="comment">/*context*/</span>,</span><br><span class="line">        QueryProcessingStage::Enum <span class="comment">/*processed_stage*/</span>,</span><br><span class="line">        size_t <span class="comment">/*max_block_size*/</span>,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="comment">/*num_streams*/</span>)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">"Method read is not supported by storage "</span> + getName(), ErrorCodes::NOT_IMPLEMENTED);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IStorage</code> 是Clickhouse存储引擎的接口，我们直接看最关键的 <code>MergeTree</code>引擎的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/src/Storages/StorageMergeTree.cpp</span></span><br><span class="line"></span><br><span class="line">BlockOutputStreamPtr StorageMergeTree::write(<span class="keyword">const</span> ASTPtr &amp; <span class="comment">/*query*/</span>, <span class="keyword">const</span> Settings &amp; <span class="comment">/*settings*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_shared&lt;MergeTreeBlockOutputStream&gt;(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">dbms</span>/src/Storages/MergeTree/MergeTreeBlockOutputStream.cpp</span><br><span class="line"></span><br><span class="line"><span class="label">void</span> MergeTreeBlockOutputStream::write(const <span class="keyword">Block </span>&amp; <span class="keyword">block)</span><br><span class="line"></span>&#123;</span><br><span class="line">    storage<span class="preprocessor">.data</span>.delayInsertOrThrowIfNeeded()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    auto part_blocks = storage.writer.splitBlockIntoParts(<span class="keyword">block);</span><br><span class="line"></span>    for (auto &amp; current_block : part_blocks)</span><br><span class="line">    &#123;</span><br><span class="line">        Stopwatch watch<span class="comment">;</span></span><br><span class="line"><span class="label"></span><br><span class="line">        MergeTreeData:</span>:MutableDataPartPtr part = storage.writer.writeTempPart(current_block)<span class="comment">;</span></span><br><span class="line">        storage<span class="preprocessor">.data</span>.renameTempPartAndAdd(part, &amp;storage.increment)<span class="comment">;</span></span><br><span class="line"><span class="label"></span><br><span class="line">        PartLog:</span>:<span class="keyword">addNewPart(storage.context, </span>part, watch.elapsed())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        /// Initiate async merge - <span class="keyword">it </span>will <span class="keyword">be </span>done <span class="preprocessor">if</span> <span class="keyword">it's </span>good time for merge <span class="keyword">and </span><span class="preprocessor">if</span> there are <span class="preprocessor">space</span> in <span class="string">'background_pool'</span>.</span><br><span class="line">        storage.<span class="keyword">background_task_handle-&gt;wake();</span><br><span class="line"></span>    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>追踪到最底层的 <code>MergeTreeBlockOutputStream</code> 我们会发现最终数据由<code>MergeTreeDataWriter</code>(<code>dbms/src/Storages/MergeTree/MergeTreeDataWriter.h</code>)写入，而<code>MergeTreeDataWriter</code>是<code>MergeTreeData</code>(<code>dbms/src/Storages/MergeTree/MergeTreeData.h</code>)的封装，<code>MergeTree</code>的数据都由<code>MergeTreeData</code>对象管理。存储的格式可以看看<a href="http://jackpgao.github.io/2017/12/06/ClickHouse-Primary-key/" target="_blank" rel="external">这篇文章</a>，后面可能会另写文再说说。</p>
<p><code>MergeTreeBlockOutputStream</code>一次写入一个<code>Block</code>,然后会唤醒后台任务将一个个小的<code>Block</code>合并。这应该就是<code>MergeTree</code>命名的由来了。由此我们可知，Clickhouse应尽可能的批量写入数据而不是一条一条的写。</p>
<p>最后再回来往上走，看看是在哪里调用最外层的 <code>write</code>方法写入的。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void TCPHandler::processInsertQuery(const Settings &amp; global_settings)</span><br><span class="line">&#123;</span><br><span class="line">    /** Made above the rest of the lines, so that <span class="keyword">in</span> case of `writePrefix` function throws an exception,</span><br><span class="line">      *  client receive exception before sending data.</span><br><span class="line">      */</span><br><span class="line">    <span class="keyword">state</span>.io.out-&gt;writePrefix();</span><br><span class="line"></span><br><span class="line">    /// Send <span class="built_in">block</span> <span class="keyword">to</span> the client - <span class="built_in">table</span> structure.</span><br><span class="line">    Block <span class="built_in">block</span> = <span class="keyword">state</span>.io.out-&gt;getHeader();</span><br><span class="line">    sendData(<span class="built_in">block</span>);</span><br><span class="line"></span><br><span class="line">    readData(global_settings);    <span class="variable">&lt;--- here</span><br><span class="line">    state.io.out-&gt;</span>writeSuffix();</span><br><span class="line">    <span class="keyword">state</span>.io.<span class="keyword">on</span>Finish();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TCPHandler::readData(const Settings &amp; global_settings)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	receiveData()</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool TCPHandler::receiveData()</span><br><span class="line">&#123;</span><br><span class="line">   	... </span><br><span class="line">    /// Read one <span class="built_in">block</span> <span class="keyword">from</span> the network and write it down</span><br><span class="line">    Block <span class="built_in">block</span> = <span class="keyword">state</span>.block_in-&gt;read();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">        if (<span class="built_in">block</span>)</span><br><span class="line">            <span class="keyword">state</span>.io.out-&gt;write(<span class="built_in">block</span>);</span><br><span class="line">        return true;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取">读取</h2><p>读取最外层<code>BlockStream</code>的地方就在<code>processOrdinaryQuery</code>。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// dbms/programs/server/TCPHandler.cpp</span><br><span class="line"></span><br><span class="line">void TCPHandler::processOrdinaryQuery()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">	AsynchronousBlockInputStream async_in(<span class="keyword">state</span>.io.<span class="keyword">in</span>);</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">block</span> = async_in.read();</span><br><span class="line">	...</span><br><span class="line">	sendData(<span class="built_in">block</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的<code>InterpreterFactory::get</code>方法可以看到Select语句会在初始化<code>InterpreterSelectQuery</code>, 于是我们来到<code>InterpreterSelectQuery.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">dbms/src/Interpreters/InterpreterSelectQuery.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InterpreterSelectQuery::executeImpl(....)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> optimize_prewhere = [&amp;](<span class="keyword">auto</span> &amp; merge_tree)</span><br><span class="line">        &#123;</span><br><span class="line">            SelectQueryInfo query_info;</span><br><span class="line">            query_info.query = query_ptr;</span><br><span class="line">            query_info.sets = query_analyzer-&gt;getPreparedSets();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Try transferring some condition from WHERE to PREWHERE if enabled and viable</span></span><br><span class="line">            <span class="keyword">if</span> (settings.optimize_move_to_prewhere &amp;&amp; query.where_expression &amp;&amp; !query.prewhere_expression &amp;&amp; !query.final())</span><br><span class="line">                MergeTreeWhereOptimizer&#123;query_info, context, merge_tree.getData(), query_analyzer-&gt;getRequiredSourceColumns(), <span class="built_in">log</span>&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">	AnalysisResult expressions;	</span><br><span class="line"></span><br><span class="line">	expressions = analyzeExpressions(from_stage, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Read the data from Storage. from_stage - to what stage the request was completed in Storage. */</span></span><br><span class="line">    executeFetchColumns(from_stage, pipeline, expressions.prewhere_info, expressions.columns_to_remove_after_prewhere);</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">if</span> (expressions.has_where)</span><br><span class="line">        executeWhere(pipeline, expressions.before_where, expressions.remove_where_filter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expressions.need_aggregate)</span><br><span class="line">        executeAggregation(pipeline, expressions.before_aggregation, aggregate_overflow_row, aggregate_final);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        executeExpression(pipeline, expressions.before_order_and_select);</span><br><span class="line">        executeDistinct(pipeline, <span class="literal">true</span>, expressions.selected_columns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!expressions.second_stage &amp;&amp; !expressions.need_aggregate &amp;&amp; !expressions.has_having)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (expressions.has_order_by)</span><br><span class="line">            executeOrder(pipeline);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expressions.has_order_by &amp;&amp; query.limit_length)</span><br><span class="line">            executeDistinct(pipeline, <span class="literal">false</span>, expressions.selected_columns);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (query.limit_length)</span><br><span class="line">            executePreLimit(pipeline);</span><br><span class="line">     .....       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最底层的<code>IBlockInputStream</code>通过<code>executeFetchColumns</code>方法从<code>storage</code>里面读取出来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="constant">InterpreterSelectQuery:</span><span class="symbol">:executeFetchColumns</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	pipeline.streams = storage-&gt;read(required_columns, query_info, context, processing_stage, max_block_size, max_streams);</span><br><span class="line"></span><br><span class="line">	if (pipeline.streams.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pipeline.streams.emplace_back(<span class="symbol">std:</span><span class="symbol">:make_shared&lt;NullBlockInputStream&gt;</span>(storage-&gt;getSampleBlockForColumns(required_columns)));</span><br><span class="line"></span><br><span class="line">            if (query_info.prewhere_info)</span><br><span class="line">                pipeline.streams.back() = <span class="symbol">std:</span><span class="symbol">:make_shared&lt;FilterBlockInputStream&gt;</span>(</span><br><span class="line">                        pipeline.streams.back(), prewhere_info-&gt;prewhere_actions,</span><br><span class="line">                        prewhere_info-&gt;prewhere_column_name, prewhere_info-&gt;remove_prewhere_column</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟写入过程类似, StorageMergeTree调用封装了<code>MergeTreeData</code>的<code>MergeTreeDataSelectExecutor</code>的<code>read</code>方法从存储里面获取数据。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dbms/programs/src/Storages/StorageMergeTree.cpp</span></span><br><span class="line"></span><br><span class="line">BlockInputStreams StorageMergeTree::read(...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> reader.<span class="title">read</span><span class="params">(column_names, query_info, context, max_block_size, num_streams, <span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<code>InterpreterSelectQuery</code>, <code>executeFetchColumns</code>方法取出数据后会调用各种<code>executeXXX</code>方法再给套上各种数据处理的<code>BlockStream</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">void</span> InterpreterSelectQuery::executeWhere(Pipeline &amp; pipeline, <span class="keyword">const</span> ExpressionActionsPtr &amp; expression, <span class="keyword">bool</span> remove_fiter)</span><br><span class="line">&#123;</span><br><span class="line">    pipeline.transform([&amp;](<span class="keyword">auto</span> &amp; stream)</span><br><span class="line">    &#123;</span><br><span class="line">        stream = <span class="built_in">std</span>::make_shared&lt;FilterBlockInputStream&gt;(stream, expression, query.where_expression-&gt;getColumnName(), remove_fiter);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InterpreterSelectQuery::executeAggregation(Pipeline &amp; pipeline, <span class="keyword">const</span> ExpressionActionsPtr &amp; expression, <span class="keyword">bool</span> overflow_row, <span class="keyword">bool</span> final)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高性能">高性能</h2><p>Clickhouse<a href="https://clickhouse.yandex/docs/zh/development/architecture" target="_blank" rel="external">文档</a>里面提到了Clickhouse高性能的秘密是vectorized query execution 和 runtime code generation，即向量化SIMD的运用和JIT。这两点是怎么体现的呢？</p>
<h3 id="JIT">JIT</h3><p>其实我们只要在代码里面搜<code>USE_EMBEDDED_COMPILER</code>这个编译宏就可以找出所有JIT相关的代码。最主要的地方在<code>dbms/src/Interpreters/ExpressionJIT.cpp</code>里面。</p>
<p>若是开启了<code>USE_EMBEDDED_COMPILER</code>， <code>compileFunctions</code>函数会将复杂的表达式即时编译成机器码执行, Clickhouse会缓存编译结果，由此提高性能。</p>
<h3 id="SIMD">SIMD</h3><p>SIMD (Single Instruction Multiple Data) 是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“数据向量”）中的每一个分别执行相同的操作从而实现空间上的并行性的技术。简单来说就是一条指令处理多个数据，由此来提升性能。</p>
<p>SIMD技术需要CPU支持SIMD的指令集，如<a href="https://zh.wikipedia.org/wiki/MMX" target="_blank" rel="external">MMX</a>、<a href="https://zh.wikipedia.org/wiki/MMX" target="_blank" rel="external">SSE</a>、<a href="https://zh.wikipedia.org/wiki/AVX%E6%8C%87%E4%BB%A4%E9%9B%86" target="_blank" rel="external">AVX</a>。</p>
<p>Clickhouse使用的是SSE2，我们可以在代码里面搜<code>__SSE2__</code>这个编译宏找出所有SIMD相关的代码。Clickhouse在许多地方比如过滤，压缩，字符串处理函数等都有用到<code>__SSE2__</code>。比较多的地方还是在过滤，毕竟是最常用的场景。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sineyuan.github.io/2018/12/09/clickhouse-source-guide/" data-id="cjpny5rto000gjm13aghqfzhh" class="article-share-link">Share</a>
      
        <a href="http://sineyuan.github.io/2018/12/09/clickhouse-source-guide/#disqus_thread" class="article-comment-link">Comments</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/01/14/clickhouse-kafka/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">从kafka导入数据到Clickhouse</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">STep by STep</a>
      &copy; 2018 Sine Yuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    
<script>
  var disqus_shortname = 'sineyuansblog';
  
  var disqus_url = 'http://sineyuan.github.io/2018/12/09/clickhouse-source-guide/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/jquery.scrollLoading.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>